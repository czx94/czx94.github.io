<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Tensorflow学习笔记7(tf.slim）]]></title>
    <url>%2F2018%2F04%2F18%2FTensorflow7%2F</url>
    <content type="text"><![CDATA[What’s tf.slim?#]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[木心语录]]></title>
    <url>%2F2018%2F04%2F18%2Fwords_of_muxin%2F</url>
    <content type="text"><![CDATA[往过去看，一代比一代多情，往未来看，一代比一代无情。多情可以多到没际涯，无情则有限，无情而已。 好看的人，咬指甲时尤其好看。 那口唇美得已是一个吻。 雨后，总像有谁离去了。 容易钟情的人，是无酒量的贪杯者。 岁月不饶人，我亦未曾饶过岁月。 我追索人心的深度，却看到人心的浅薄。 麻木的人都爱说，跟着感觉走。 玩物丧志，其志小，志大者玩物养志。 美无性别，若有性别则是性不是美。 你常常笑得使我看不清。 给他们面子，是我自己要面子。 我的存在，已是礼节性的存在。 我是一个在黑暗中大雪纷飞的人哪，你再不来，我要下雪了。 从前的那个我，如果来找现在的我，会得到很好的款待。]]></content>
      <categories>
        <category>语录</category>
      </categories>
      <tags>
        <tag>无病呻吟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代诗]]></title>
    <url>%2F2018%2F04%2F18%2Fmodern_poem%2F</url>
    <content type="text"><![CDATA[从前慢 木心记得早先少年时大家诚诚恳恳说一句 是一句 清早上火车站长街黑暗无行人卖豆浆的小店冒着热气 从前的日色变得慢车，马，邮件都慢一生只够爱一个人 从前的锁也好看钥匙精美有样子你锁了 人家就懂了 波兰来客 北岛那时我们有梦想，关于文学，关于爱情，关于穿越世界的旅行。如今我们深夜饮酒，杯子碰到一起，都是梦破碎的声音。 Every Day You Play Pablo NerudaEvery day you play with the light of the universe.Subtle visitor, you arrive in the flower and the water,You are more than this white head that I hold tightlyas a bunch of flowers, every day, between my hands. You are like nobody since I love you.Let me spread you out among yellow garlands.Who writes your name in letters of smoke among the stars of the south?Oh let me remember you as you were before you existed. Suddenly the wind howls and bangs at my shut window.The sky is a net crammed with shadowy fish.Here all the winds let go sooner or later, all of them.The rain takes off her clothes. The birds go by, fleeing.The wind. The wind.I alone can contend against the power of men.The storm whirls dark leavesand turns loose all the boats that were moored last night to the sky. You are here. Oh, you do not run away.You will answer me to the last cry.Curl round me as though you were frightened.Even so, a strange shadow once ran through your eyes. Now, now too, little one, you bring me honeysuckle,and even your breasts smell of it.While the sad wind goes slaughtering butterfliesI love you, and my happiness bites the plum of your mouth. How you must have suffered getting accustomed to me,my savage, solitary soul, my name that sends them all running.So many times we have seen the morning star burn, kissing our eyes,and over our heads the grey light unwinds in turning fans. My words rained over you, stroking you.A long time I have loved the sunned mother-of-pearl of your body.Until I even believe that you own the universe.I will bring you happy flowers from the mountains, bluebells, dark hazels, and rustic baskets of kisses.I want to do with you what spring does with the cherry trees. 过程 林白一月你还没有出现二月你睡在隔壁三月下起了大雨四月里遍地蔷薇五月我们对面坐着 犹如梦中 就这样六月到了 六月里青草盛开 处处芬芳七月，悲喜交加 麦浪翻滚连同草地 直到天涯八月就是八月八月我守口如瓶 八月里我是瓶中的水 你是青天的云九月和十月 是两只眼睛，装满了大海你在海上 我在海下十一月尚未到来透过它的窗口 我望见了十二月 十二月大雪弥漫 门前 顾城我多么希望，有一个门口 早晨，阳光照在草上 我们站着 扶着自己的门扇 门很低，但太阳是明亮的 草在结它的种子 风在摇它的叶子 我们站着，不说话 就十分美好 有门，不用开开 是我们的，就十分美好 早晨，黑夜还要流浪 我们把六弦琴交给他 我们不走了 我们需要土地 需要永不毁灭的土地 我们要乘着它 度过一生 土地是粗糙的，有时狭隘 然而，它有历史 有一份天空，一份月亮 一份露水和早晨 我们爱土地 我们站着 用木鞋挖着泥土 门也晒热了 我们轻轻靠着，十分美好 墙后的草 不会再长大了它只用指尖，触了触阳光 我曾经爱过你 普希金我曾经爱过你：爱情，也许在我的心灵里还没有完全消亡，但愿它不会再打扰你，我也不想再使你难过悲伤。我曾经默默无语、毫无指望地爱过你，我既忍受着羞怯，又忍受着嫉妒的折磨，我曾经那样真诚、那样温柔地爱过你，但愿上帝保佑你，另一个人也会像我一样地爱你。 借我 樊小纯（一说是木心先生本人）借我一个暮年，借我碎片，借我瞻前与顾后，借我执拗如少年。借我后天长成的先天，借我变如不曾改变。借我素淡的世故和明白的愚，借我可预知的脸。借我悲怆的磊落，借我温软的鲁莽和玩笑的庄严。借我最初与最终的不敢，借我不言而喻的不见。借我一场秋啊，可你说这已是冬天。 When You Are Old William Butler YeatsWhen you are old and grey and full of sleep,And nodding by the fire, take down this book,And slowly read, and dream of the soft lookYour eyes had once, and of their shadows deep; How many loved your moments of glad grace,And loved your beauty with love false or true,But one man loved the pilgrim soul in you,And loved the sorrows of your changing face; And bending down beside the glowing bars,Murmur, a little sadly, how Love fledAnd paced upon the mountains overheadAnd hid his face amid a crowd of stars. 夏天的太阳 海子夏天如果这条街没有鞋匠 我就打赤脚站到太阳下看太阳 我想到在白天出生的孩子一定是出于故意 你来人间一趟你要看看太阳 和你的心上人一起走在街上 了解她也要了解太阳 （一组健康的工人正午抽着纸烟） 夏天的太阳太阳 当年基督入世他也在这阳光下长大 1985.1 答案 顾城这是最美的季节可以忘记梦想到处都是花朵满山阴影飘荡 这是最美的阴影可以摇动阳光轻轻走下山去酒杯叮当作响 这是最美的酒杯可以发出歌唱放上花香捡回四边都是太阳 这是最美的太阳把花印在地上谁要拾走影子谁就拾走光芒 Gift Czesław MiłoszA day so happy.Fog lifted early. I worked in the garden.Hummingbirds were stopping over the honeysuckle flowers.There was no thing on earth I wanted to possess.I knew no one worth my envying him.Whatever evil I had suffered, I forgot.To think that once I was the same man did not embarrass me.In my body I felt no pain.When straightening up, I saw blue sea and sails. 日子过得多么舒畅。晨雾早早消散，我在院中劳动。成群蜂鸟流连在金银花丛。人世间我再也不需要别的事物。没有任何人值得我羡慕。遇到什么逆运，我都把它忘在一边。想到往昔的日子，也不觉得羞惭。我一身轻快，毫无痛苦。昂首远望，唯见湛蓝大海上点点白帆。 身体清单 李庄身体里的碳可以制成九千支铅笔赠给诗人但每根铅笔必须配一块橡皮 身体里的磷要制成两千根火柴全部给盲者让他点燃血中的火焰 身体里的脂肪还能做八块肥皂送给妓女请她洗净骨头去做母亲 身体里的铁只够打一枚钢钉留给我飘泊一世的灵魂就钉在爱人的心上 The Sweetest Little Song Leonard CohenYou go your wayI’ll go your way too 我想和你虚度时光 李元胜我想和你虚度时光，比如低头看鱼比如把茶杯留在桌子上，离开浪费它们好看的阴影我还想连落日一起浪费，比如散步一直消磨到星光满天我还要浪费风起的时候坐在走廊发呆，直到你眼中乌云全部被吹到窗外我已经虚度了世界，它经过我疲倦，又像从未被爱过但是明天我还要这样，虚度满目的花草，生活应该像它们一样美好一样无意义，像被虚度的电影那些绝望的爱和赴死为我们带来短暂的沉默我想和你互相浪费一起虚度短的沉默，长的无意义一起消磨精致而苍老的宇宙比如靠在栏杆上，低头看水的镜子直到所有被虚度的事物在我们身后，长出薄薄的翅膀 青春 席慕容所有的结局都已写好所有的泪水都已启程却忽然忘了是怎么样的一个开始在那个古老的不再回来的夏日无论我如何的去追索年轻的你只如云影掠过而你微笑的面容极浅极淡逐渐隐没在日后的群岚遂翻开那发黄的扉页命运将它装订得极其拙劣含着泪我一读再读却不得不承认青春是一本太仓促的书 我是一个任性的孩子 顾城我希望能在心爱的白纸上画画画出笨拙的自由画下一只永远不会流泪的眼睛 我是一个任性的孩子我想涂去一切不幸我想在大地上画满窗子让所有习惯黑暗的眼睛都习惯光明 我和这个世界不熟 北岛我和这个世界不熟。这并非是我安静的原因。我依旧有很多问题，问南方，问故里，问希望，问距离。 我和这个世界不熟。这并非是我绝望的原因。我依旧有很多热情，给分开，给死亡，给昨天，给安寂。 我和这个世界不熟。这并非是我虚假的原因。我依旧有很多真诚，离不开，放不下，活下去，爱得起。 我和这个世界不熟。这并非是我孤寂的原因。我依旧有很多诉求，需慰藉，待分享，惹心烦，告诉你。 我和这个世界不熟。这并非是我冷漠的原因。我依旧有很多动情，为时间，为白云，为天黑，畏天命。 我和这个世界不熟。这并非是我逃避的原因。我依旧有很多憧憬，对梦想，对记忆，对失败，对希冀。 我和这个世界不熟。这并非是我卑微的原因。我依旧有很多勇敢，不信输，不信神，不信天，不信地。 我和这个世界不熟。这并非是我失落的原因。我依旧有很多高昂，有存在，有价值，有独特，有意义。 我和这个世界不熟。这并非是我迷茫的原因。我依旧有很多方向，往前走，回头望，会跳跃，会停息。 我和这个世界不熟。这并非是我撕裂的原因。我依旧有很多完整，至少我要成全我自己。 我和这个世界不熟。这并非是我选择死亡或者生存的原因。我依旧有很多选择，刚巧，这两者，都不是选项之一。 眉目 木心你的眉目笑语使我病了一场热势退尽，还我寂寞的健康如若再晤见，感觉是远远的像有人在地平线上走，走过只剩地平线，早春的雾迷濛了所幸的是你毕竟算不得美美，我就病重，就难痊愈你这点儿才貌只够我病十九天第二十天你就粗糙难看起来你一生的华彩乐段也就完了别人怎会当你是什么宝贝呢蔓草丛生，细雨如粉，鹧鸪幽啼我将迁徙，卜居森林小丘之陬静等那足够我爱的人物的到来 今夜我可以写出最悲哀的诗行 聂鲁达今夜我可以写出最悲哀的诗行。 可以写出：比如：“夜繁星满布，天蓝色，星星们，在远处，颤抖着。” 夜风在空中旋转并歌唱。 今夜我可以写出最悲哀的诗行。我爱过她，有时她也爱过我。 在那些如今夜一般的夜里我拥过她入怀。在无尽的天空下我吻过她那么多遍。 她爱过我，有时我也爱过她。怎会不爱上她直勾勾的大眼睛。 今夜我可以写出最悲哀的诗行。可以想到不是正拥着她。可以感到失去了她。 听到浩渺的夜，没有她更加浩渺。而诗句落向灵魂如同向着牧草露水落下。 我的爱没能留住她又有什么关系。夜繁星满布而她没和我一起。 这便是一切。远处有人在歌唱。在远处。我的灵魂不甘于失去了她。 如同为了靠近她我的目光搜寻着她。我的心搜寻着她，而她没和我一起。 把那些同样的树涂白的同样的夜。而我们，那时的我们，现在不再是同样的了。 我不再爱她，肯定是，可我多么深地爱过她。我的声音曾一直搜寻风去触她的耳。 属于别人。要属于别人了。就像之前属于我的吻。她的声音，她明亮的身体。她无尽的眼睛。 我不再爱她，肯定是，可也许我仍爱着她。爱情太短，而遗忘太过漫长。 因为在那些如今夜一般的夜里我拥过她入怀，我的灵魂不甘于失去了她。 虽然这是她带给我的最后的痛苦，而这些是我正为她写出的最后的诗行。 在此我爱你 聂鲁达在此我爱你。风在幽暗的松林里解开自己。月亮在游荡的水上发出磷光。同样的日子相互追逐纠缠。 雾气散开成舞蹈的形体。一只银色的海鸥从西天滑落。有时一片帆。高高，高高在上的星星。 或者一条船的黑色十字。孤独的。有时清晨醒来，连我的灵魂也是湿的。海远远地发声，又发声。这是港口。在此我爱你。 在此我爱你，而地平线徒劳地将你遮掩。置身这些冰冷的东西中我依然爱你。有时我的吻登上那些沉重的船只由海上驶向无法到达的地方。 我看见自己如那些旧锚般被遗忘。当黄昏靠岸，码头格外悲伤。我的生命已倦，毫无成效的饥饿。我爱我没有的东西。你如此遥远。我的厌烦与缓慢的暮色搏斗着。但夜来临，并开始对我歌唱。 月亮转动它梦的圆盘。最大的那些星星藉你的眼睛望着我。而因为我爱你，风中的松树要用它们的针叶歌唱你的名。 中药 冯唐世间草木都美人不是 中药很苦你也是。]]></content>
      <categories>
        <category>现代诗</category>
      </categories>
      <tags>
        <tag>无病呻吟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow学习笔记6(Transfer Learning迁移学习）]]></title>
    <url>%2F2018%2F04%2F18%2FTensorflow6%2F</url>
    <content type="text"><![CDATA[Dogs vs. Cats这次用的数据集来自 kaggle 上的一个竞赛：Dogs vs. Cats，训练集有25000张，猫狗各占一半。测试集12500张，没有标定是猫还是狗。首先用一个3层conv+pooling和3层fc的网络来学习，这个模型在batch=32的情况下，收敛比较不稳定。但是经过7000个epoch，测试集准确率也达到70%。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155import tensorflow as tfimport inputimport os#Hyperparameterslearning_rate = 0.0001batch_size = 32dropout = 0.5training_iters = 100000display_step = 30#paramslength = 224width = 256dimension = 3n_classes = 2os.environ["CUDA_DEVICE_ORDER"]="PCI_BUS_ID" # see issue #152os.environ["CUDA_VISIBLE_DEVICES"]="0"#create data generatortrain_generator = input.trainGenerator(int(batch_size/2), length, width)val_generator = input.valGenerator(int(batch_size/2), length, width)#iox = tf.placeholder('float', [None, length, width, dimension])y = tf.placeholder('float', [None, n_classes])keep_prob = tf.placeholder(tf.float32)#kernel sizeweights = &#123; 'c1': tf.Variable(tf.truncated_normal([3,3,3,32], stddev=0.001, name='wc1')), 'c2': tf.Variable(tf.truncated_normal([3,3,32,32], stddev=0.01, name='wc2')), 'c3': tf.Variable(tf.truncated_normal([3,3,32,64], stddev=0.01, name='wc3')), 'f1': tf.Variable(tf.truncated_normal([32*28*64, 512], stddev=0.01, name='fc1')), 'f2': tf.Variable(tf.truncated_normal([512, 128], stddev=0.1, name='fc2')), 'f3': tf.Variable(tf.truncated_normal([128, 2], stddev=0.1, name='fc3')),&#125;biases = &#123; 'c1': tf.Variable(tf.constant(0.01, shape=[32], name='bc1')), 'c2': tf.Variable(tf.constant(0.01, shape=[32], name='bc2')), 'c3': tf.Variable(tf.constant(0.01, shape=[64], name='bc3')), 'f1': tf.Variable(tf.constant(0.1, shape=[512], name='fb1')), 'f2': tf.Variable(tf.constant(0.1, shape=[128], name='fb2')), 'f3': tf.Variable(tf.constant(0.1, shape=[2], name='fb3'))&#125;#funcsdef conv2d(input, kernel, bias, name): wx_plus_b = tf.nn.bias_add(tf.nn.conv2d(input, kernel, strides=[1,1,1,1], padding='SAME'), bias) batch_norm = bn_layer(wx_plus_b, True, name) return tf.nn.sigmoid(batch_norm, name=name)def pooling(input, k, name): return tf.nn.max_pool(input, ksize=[1,k,k,1], strides=[1,k,k,1], padding='SAME', name=name)# 实现Batch Normalizationdef bn_layer(x,is_training,name,moving_decay=0.9,eps=1e-5): # 获取输入维度并判断是否匹配卷积层(4)或者全连接层(2) shape = x.shape assert len(shape) in [2,4] param_shape = shape[-1] with tf.variable_scope(name): # 声明BN中唯一需要学习的两个参数，y=gamma*x+beta gamma = tf.get_variable('gamma',param_shape,initializer=tf.constant_initializer(1)) beta = tf.get_variable('beat', param_shape,initializer=tf.constant_initializer(0)) # 计算当前整个batch的均值与方差 axes = list(range(len(shape)-1)) batch_mean, batch_var = tf.nn.moments(x,axes,name='moments') # 采用滑动平均更新均值与方差 ema = tf.train.ExponentialMovingAverage(moving_decay) def mean_var_with_update(): ema_apply_op = ema.apply([batch_mean,batch_var]) with tf.control_dependencies([ema_apply_op]): return tf.identity(batch_mean), tf.identity(batch_var) # 训练时，更新均值与方差，测试时使用之前最后一次保存的均值与方差 mean, var = tf.cond(tf.equal(is_training,True),mean_var_with_update, lambda:(ema.average(batch_mean),ema.average(batch_var))) # 最后执行batch normalization return tf.nn.batch_normalization(x,mean,var,beta,gamma,eps)def fc_layer(input, weight, bias, name, batch_norm = True): wx_plus_b = tf.matmul(input, weight) + bias if batch_norm: wx_plus_b = bn_layer(wx_plus_b, True, name) return tf.nn.sigmoid(wx_plus_b, name=name)#modeldef alexnet(X, weights, biases, dropout): # X = tf.reshape(X, [-1, 28, 28, 1]) #conv1 conv1 = conv2d(X, weights['c1'], biases['c1'], 'conv1') pool1 = pooling(conv1, 2, 'pool1') norm1 = tf.nn.dropout(pool1, dropout) # conv2 conv2 = conv2d(norm1, weights['c2'], biases['c2'], 'conv2') pool2 = pooling(conv2, 2, 'pool2') norm2 = tf.nn.dropout(pool2, dropout) # conv3 conv3 = conv2d(norm2, weights['c3'], biases['c3'], 'conv3') pool3 = pooling(conv3, 2, 'pool3') norm3 = tf.nn.dropout(pool3, dropout) #fc fc1 = tf.reshape(norm3, [-1, weights['f1'].get_shape().as_list()[0]]) fc1 = fc_layer(fc1, weights['f1'], biases['f1'], 'fc1') fc2 = fc_layer(fc1, weights['f2'], biases['f2'], 'fc2') fc2 = tf.nn.dropout(fc2, dropout) fc3 = fc_layer(fc2, weights['f3'], biases['f3'], 'fc3', batch_norm=False) return fc3#construct modelmodel = alexnet(x, weights, biases, keep_prob)#learnloss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=y, logits=model))optimizer = tf.train.AdamOptimizer(learning_rate=learning_rate).minimize(loss)correct_prediction = tf.equal(tf.argmax(model,1), tf.argmax(y,1))accuracy = tf.reduce_mean(tf.cast(correct_prediction, "float"))#initinit = tf.initialize_all_variables()#run!with tf.Session() as sess: sess.run(init) step = 0 # Keep training until reach max iterations while step &lt; training_iters: batch_xs, batch_ys = next(train_generator) # get batch data sess.run(optimizer, feed_dict=&#123;x: batch_xs, y: batch_ys, keep_prob: dropout&#125;) if step % display_step == 0: # res = sess.run(model, feed_dict=&#123;x: batch_xs, y: batch_ys, keep_prob: 1.&#125;) # print(res) # Train acc acc = sess.run(accuracy, feed_dict=&#123;x: batch_xs, y: batch_ys, keep_prob: 1.&#125;) # train loss loss_val = sess.run(loss, feed_dict=&#123;x: batch_xs, y: batch_ys, keep_prob: 1.&#125;) print ("Iter " + str(step) + ", Minibatch Loss= " + "&#123;:.6f&#125;".format(loss_val) + ", Training Accuracy= " + "&#123;:.5f&#125;".format(acc)) # Test acc if step % 100 == 0: batch_x, batch_y = next(val_generator) print("Validation Accuracy:", sess.run(accuracy, feed_dict=&#123;x: batch_x, y: batch_y, keep_prob: 1.&#125;),"loss:", sess.run(loss, feed_dict=&#123;x: batch_xs, y: batch_ys, keep_prob: 1.&#125;)) step += 1 print ("Optimization Finished!") What’s transfer learning通过使用之前在大数据集上经过训练的预训练模型，我们可以直接使用相应的结构和权重，将它们应用到我们正在面对的问题上。这被称作是“迁移学习”，即将预训练的模型“迁移”到我们正在应对的特定问题中。严格来说，这种迁移的方式是一种模型迁移。在具体操作的时候，将一个预先训练好的神经网络，用新数据集重新训练网络中的一小部分，通常是最后一层或者几层全连接层，卷积层一般不动。从而完成在新数据集上建立的算法任务，即完成了神经网络的迁移学习。我们可以理解成将前面固定不动的部分作为一个特征提取器，而后面训练的层作为分类器。具体训练哪些层，也取决于使用的预训练模型和现有的标注数据的规模： Why we need transfer learning之后想着用一个复杂一点的模型来拟合，Alexnet和VGG16之类的，但是试了一下，发现都没法收敛。刚开始还想是不是模型或者超参数哪里出了问题，调了半天。后来觉得可能是因为数据量小而模型过于复杂导致的。所以这时候如果还希望用这些复杂网络，最好的办法就是到网上去下载网络的预训练模型(pretrained model)，然后对最后几层进行fine tuning。 Inception_V3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259import globimport os.pathimport randomimport numpy as npimport tensorflow as tffrom tensorflow.python.platform import gfile# Inception-v3模型瓶颈层的节点个数BOTTLENECK_TENSOR_SIZE = 2048# Inception-v3模型中代表瓶颈层结果的张量名称。# 在谷歌提出的Inception-v3模型中，这个张量名称就是'pool_3/_reshape:0'。# 在训练模型时，可以通过tensor.name来获取张量的名称。BOTTLENECK_TENSOR_NAME = 'pool_3/_reshape:0'# 图像输入张量所对应的名称。JPEG_DATA_TENSOR_NAME = 'DecodeJpeg/contents:0'# 下载的谷歌训练好的Inception-v3模型文件目录MODEL_DIR = 'model/'# 下载的谷歌训练好的Inception-v3模型文件名MODEL_FILE = 'tensorflow_inception_graph.pb'# 因为一个训练数据会被使用多次，所以可以将原始图像通过Inception-v3模型计算得到的特征向量保存在文件中，免去重复的计算。# 下面的变量定义了这些文件的存放地址。CACHE_DIR = 'tmp/bottleneck/'# 图片数据文件夹。# 在这个文件夹中每一个子文件夹代表一个需要区分的类别，每个子文件夹中存放了对应类别的图片。INPUT_DATA = 'train/'# 验证的数据百分比VALIDATION_PERCENTAGE = 10# 测试的数据百分比TEST_PERCENTAGE = 10# 定义神经网络的设置LEARNING_RATE = 0.01STEPS = 4000BATCH = 100# 这个函数从数据文件夹中读取所有的图片列表并按训练、验证、测试数据分开。# testing_percentage和validation_percentage参数指定了测试数据集和验证数据集的大小。def create_image_lists(testing_percentage, validation_percentage): # 得到的所有图片都存在result这个字典(dictionary)里。 # 这个字典的key为类别的名称，value也是一个字典，字典里存储了所有的图片名称。 result = &#123;&#125; # 获取当前目录下所有的子目录 sub_dirs = [x[0] for x in os.walk(INPUT_DATA)] # 得到的第一个目录是当前目录，不需要考虑 is_root_dir = True for sub_dir in sub_dirs: if is_root_dir: is_root_dir = False continue # 获取当前目录下所有的有效图片文件。 extensions = ['jpg', 'jpeg', 'JPG', 'JPEG'] file_list = [] dir_name = os.path.basename(sub_dir) for extension in extensions: file_glob = os.path.join(INPUT_DATA, dir_name, '*.'+extension) file_list.extend(glob.glob(file_glob)) if not file_list: continue # 通过目录名获取类别的名称。 label_name = dir_name.lower() # 初始化当前类别的训练数据集、测试数据集和验证数据集 training_images = [] testing_images = [] validation_images = [] for file_name in file_list: base_name = os.path.basename(file_name) # 随机将数据分到训练数据集、测试数据集和验证数据集。 chance = np.random.randint(100) if chance &lt; validation_percentage: validation_images.append(base_name) elif chance &lt; (testing_percentage + validation_percentage): testing_images.append(base_name) else: training_images.append(base_name) # 将当前类别的数据放入结果字典。 result[label_name] = &#123; 'dir': dir_name, 'training': training_images, 'testing': testing_images, 'validation': validation_images &#125; # 返回整理好的所有数据 return result# 这个函数通过类别名称、所属数据集和图片编号获取一张图片的地址。# image_lists参数给出了所有图片信息。# image_dir参数给出了根目录。存放图片数据的根目录和存放图片特征向量的根目录地址不同。# label_name参数给定了类别的名称。# index参数给定了需要获取的图片的编号。# category参数指定了需要获取的图片是在训练数据集、测试数据集还是验证数据集。def get_image_path(image_lists, image_dir, label_name, index, category): # 获取给定类别中所有图片的信息。 label_lists = image_lists[label_name] # 根据所属数据集的名称获取集合中的全部图片信息。 category_list = label_lists[category] mod_index = index % len(category_list) # 获取图片的文件名。 base_name = category_list[mod_index] sub_dir = label_lists['dir'] # 最终的地址为数据根目录的地址 + 类别的文件夹 + 图片的名称 full_path = os.path.join(image_dir, sub_dir, base_name) return full_path# 这个函数通过类别名称、所属数据集和图片编号获取经过Inception-v3模型处理之后的特征向量文件地址。def get_bottlenect_path(image_lists, label_name, index, category): return get_image_path(image_lists, CACHE_DIR, label_name, index, category) + '.txt';# 这个函数使用加载的训练好的Inception-v3模型处理一张图片，得到这个图片的特征向量。def run_bottleneck_on_image(sess, image_data, image_data_tensor, bottleneck_tensor): # 这个过程实际上就是将当前图片作为输入计算瓶颈张量的值。这个瓶颈张量的值就是这张图片的新的特征向量。 bottleneck_values = sess.run(bottleneck_tensor, &#123;image_data_tensor: image_data&#125;) # 经过卷积神经网络处理的结果是一个四维数组，需要将这个结果压缩成一个特征向量（一维数组） bottleneck_values = np.squeeze(bottleneck_values) return bottleneck_values# 这个函数获取一张图片经过Inception-v3模型处理之后的特征向量。# 这个函数会先试图寻找已经计算且保存下来的特征向量，如果找不到则先计算这个特征向量，然后保存到文件。def get_or_create_bottleneck(sess, image_lists, label_name, index, category, jpeg_data_tensor, bottleneck_tensor): # 获取一张图片对应的特征向量文件的路径。 label_lists = image_lists[label_name] sub_dir = label_lists['dir'] sub_dir_path = os.path.join(CACHE_DIR, sub_dir) if not os.path.exists(sub_dir_path): os.makedirs(sub_dir_path) bottleneck_path = get_bottlenect_path(image_lists, label_name, index, category) # 如果这个特征向量文件不存在，则通过Inception-v3模型来计算特征向量，并将计算的结果存入文件。 if not os.path.exists(bottleneck_path): # 获取原始的图片路径 image_path = get_image_path(image_lists, INPUT_DATA, label_name, index, category) # 获取图片内容。 image_data = gfile.FastGFile(image_path, 'rb').read() # print(len(image_data)) # 由于输入的图片大小不一致，此处得到的image_data大小也不一致（已验证），但却都能通过加载的inception-v3模型生成一个2048的特征向量。具体原理不详。 # 通过Inception-v3模型计算特征向量 bottleneck_values = run_bottleneck_on_image(sess, image_data, jpeg_data_tensor, bottleneck_tensor) # 将计算得到的特征向量存入文件 bottleneck_string = ','.join(str(x) for x in bottleneck_values) with open(bottleneck_path, 'w') as bottleneck_file: bottleneck_file.write(bottleneck_string) else: # 直接从文件中获取图片相应的特征向量。 with open(bottleneck_path, 'r') as bottleneck_file: bottleneck_string = bottleneck_file.read() bottleneck_values = [float(x) for x in bottleneck_string.split(',')] # 返回得到的特征向量 return bottleneck_values# 这个函数随机获取一个batch的图片作为训练数据。def get_random_cached_bottlenecks(sess, n_classes, image_lists, how_many, category, jpeg_data_tensor, bottleneck_tensor): bottlenecks = [] ground_truths = [] for _ in range(how_many): # 随机一个类别和图片的编号加入当前的训练数据。 label_index = random.randrange(n_classes) label_name = list(image_lists.keys())[label_index] image_index = random.randrange(65536) bottleneck = get_or_create_bottleneck(sess, image_lists, label_name, image_index, category, jpeg_data_tensor, bottleneck_tensor) ground_truth = np.zeros(n_classes, dtype=np.float32) ground_truth[label_index] = 1.0 bottlenecks.append(bottleneck) ground_truths.append(ground_truth) return bottlenecks, ground_truths# 这个函数获取全部的测试数据。在最终测试的时候需要在所有的测试数据上计算正确率。def get_test_bottlenecks(sess, image_lists, n_classes, jpeg_data_tensor, bottleneck_tensor): bottlenecks = [] ground_truths = [] label_name_list = list(image_lists.keys()) # 枚举所有的类别和每个类别中的测试图片。 for label_index, label_name in enumerate(label_name_list): category = 'testing' for index, unused_base_name in enumerate(image_lists[label_name][category]): # 通过Inception-v3模型计算图片对应的特征向量，并将其加入最终数据的列表。 bottleneck = get_or_create_bottleneck(sess, image_lists, label_name, index, category, jpeg_data_tensor, bottleneck_tensor) ground_truth = np.zeros(n_classes, dtype = np.float32) ground_truth[label_index] = 1.0 bottlenecks.append(bottleneck) ground_truths.append(ground_truth) return bottlenecks, ground_truthsdef main(_): # 读取所有图片。 image_lists = create_image_lists(TEST_PERCENTAGE, VALIDATION_PERCENTAGE) n_classes = len(image_lists.keys()) # 读取已经训练好的Inception-v3模型。 # 谷歌训练好的模型保存在了GraphDef Protocol Buffer中，里面保存了每一个节点取值的计算方法以及变量的取值。 # TensorFlow模型持久化的问题在第5章中有详细的介绍。 with gfile.FastGFile(os.path.join(MODEL_DIR, MODEL_FILE), 'rb') as f: graph_def = tf.GraphDef() graph_def.ParseFromString(f.read()) # 加载读取的Inception-v3模型，并返回数据输入所对应的张量以及计算瓶颈层结果所对应的张量。 bottleneck_tensor, jpeg_data_tensor = tf.import_graph_def(graph_def, return_elements=[BOTTLENECK_TENSOR_NAME, JPEG_DATA_TENSOR_NAME]) # 定义新的神经网络输入，这个输入就是新的图片经过Inception-v3模型前向传播到达瓶颈层时的结点取值。 # 可以将这个过程类似的理解为一种特征提取。 bottleneck_input = tf.placeholder(tf.float32, [None, BOTTLENECK_TENSOR_SIZE], name='BottleneckInputPlaceholder') # 定义新的标准答案输入 ground_truth_input = tf.placeholder(tf.float32, [None, n_classes], name='GroundTruthInput') # 定义一层全连接层来解决新的图片分类问题。 # 因为训练好的Inception-v3模型已经将原始的图片抽象为了更加容易分类的特征向量了，所以不需要再训练那么复杂的神经网络来完成这个新的分类任务。 with tf.name_scope('final_training_ops'): weights = tf.Variable(tf.truncated_normal([BOTTLENECK_TENSOR_SIZE, n_classes], stddev=0.001)) biases = tf.Variable(tf.zeros([n_classes])) logits = tf.matmul(bottleneck_input, weights) + biases final_tensor = tf.nn.softmax(logits) # 定义交叉熵损失函数 cross_entropy = tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=ground_truth_input) cross_entropy_mean = tf.reduce_mean(cross_entropy) train_step = tf.train.GradientDescentOptimizer(LEARNING_RATE).minimize(cross_entropy_mean) # 计算正确率 with tf.name_scope('evaluation'): correct_prediction = tf.equal(tf.argmax(final_tensor, 1), tf.argmax(ground_truth_input, 1)) evaluation_step = tf.reduce_mean(tf.cast(correct_prediction, tf.float32)) with tf.Session() as sess: tf.global_variables_initializer().run() # 训练过程 for i in range(STEPS): # 每次获取一个batch的训练数据 train_bottlenecks, train_ground_truth = get_random_cached_bottlenecks( sess, n_classes, image_lists, BATCH, 'training', jpeg_data_tensor, bottleneck_tensor) sess.run(train_step, feed_dict=&#123;bottleneck_input: train_bottlenecks, ground_truth_input: train_ground_truth&#125;) # 在验证集上测试正确率。 if i%100 == 0 or i+1 == STEPS: validation_bottlenecks, validation_ground_truth = get_random_cached_bottlenecks( sess, n_classes, image_lists, BATCH, 'validation', jpeg_data_tensor, bottleneck_tensor) validation_accuracy = sess.run(evaluation_step, feed_dict=&#123; bottleneck_input:validation_bottlenecks, ground_truth_input: validation_ground_truth&#125;) print('Step %d: Validation accuracy on random sampled %d examples = %.1f%%' % (i, BATCH, validation_accuracy*100)) # 在最后的测试数据上测试正确率 test_bottlenecks, test_ground_truth = get_test_bottlenecks(sess, image_lists, n_classes, jpeg_data_tensor, bottleneck_tensor) test_accuracy = sess.run(evaluation_step, feed_dict=&#123;bottleneck_input: test_bottlenecks, ground_truth_input: test_ground_truth&#125;) print('Final test accuracy = %.1f%%' % (test_accuracy * 100))if __name__ == '__main__': tf.app.run()]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[边缘检测]]></title>
    <url>%2F2018%2F03%2F23%2Fedge-detection%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[局部特征描述和匹配]]></title>
    <url>%2F2018%2F03%2F15%2Flocal-feature-description-and-matching%2F</url>
    <content type="text"><![CDATA[SIFT这篇文章应该会很长。 IntroductionSIFT是由UBC（university of British Column）的教授David Lowe于1999年提出，并在2004年得以完善的一种检测图像关键点（key points , 或者称为图像的interest points(兴趣点) )，并对关键点提取其局部尺度不变特征的描绘子，可以采用这个描绘子进行用于对两幅相关的图像进行匹配（matching）。算法目标：将图像内容用一组局部特征表示，该特征对于平移，旋转，缩放和其他成像参数不变。SIFT特征的优点由如下几种： Locality：特征是局部的， 所以对于遮挡（occusion）和复杂的背景（clutter）的鲁棒性非常好，very robust. Distinctiveness: 特征具有独一无二性。也就是说 individual features can be matched to a large database of objects. Quantity: 即使是一个很小的物体（objects）, 也能够产生大量的SIFT features.。 Efficiency： SIFT接近于实时的性能， 效率很高。 Procedure Scale-space extrema detection这一步的目的是在尺度空间中选择选择潜在的满足尺度不变性和旋转不变性的关键点（或者称为兴趣点)。和之前DoG生成尺度空间的过程相似，需要在不同尺寸下用不同的σ的DoG去生成尺度空间。对于尺度空间大小的选择，也就是取多少个σ，实验证明3个的时候稳定的极值点最多。接下来就可以求极值了，SIFT中的极值不是单一尺度下的极值，而是要求这个点是尺度空间中的极值。所以，如下图，为了利用这个三维空间中找到图像的中的兴趣点，我们需要找到这个尺度的3x3邻域的局部极值（由于这个尺度共有3幅图像，所以共需要比较绿色区域中心点附近3x3x3-1（即26个像素），看看这个这个中心点像素的的值是否大于周围的26个像素。如果是，我们就说这个中心点是局部极值。这个点就是我们的兴趣点。以此类推，找到所有的极值点（兴趣点）。 Keypoint localization这一步的目的就是精确定位出特征关键点的位置, 涉及到剔除伪关键点。并不是所有的极值点都是关键点。而且由于对于一幅图像，我们可能找到很多的极值点，所以我们需要剔除掉一些不是关键点的点（可能是边缘的点，因为DoG对于边缘有很强的响应）。剔去的是低对比度的候选关键点 Orientation assignment这一步的目的就是基于关键点的局部梯度方向，给每个相应的关键点分配方向。 Keypoint description此步骤的目的就是对于每个关键点，用一个向量去描述每个关键点。 引用https://www.jianshu.com/p/a2366be565cb]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Computer Vision</tag>
        <tag>Point matching</tag>
        <tag>SIFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特征点检测]]></title>
    <url>%2F2018%2F03%2F13%2FInterest-Point-Detection%2F</url>
    <content type="text"><![CDATA[特征点检测有啥用？特征点检测广泛应用到目标匹配、目标跟踪、三维重建等应用中，在进行目标建模时会对图像进行目标特征的提取，常用的有颜色、角点、特征点、轮廓、纹理等特征。我们有这两张图片，想要把他们拼成一张，比如常用的全景照片。这个过程一共有三步，首先检测出两张图片特征点，然后再把对应的特征点配对，最后进行图像拼接。因为我们不可能把两张图所有的对应点都找出来，这在复杂度上很不划算，而且也不好实现。图像拼接后的结果：此外特征点检测还可以用来进行视频中物体的跟踪，比如Lucas-Kanade光流法实现目标跟踪。 Harris角点检测首先，为什么选择角点进行检测？当然是因为它们有比较容易进行判断的特征。角点在至少两个方向上会有很大的梯度，在物体内部的点没有，而边缘的点一般在某个方向梯度为0。Harris角点检测是特征点检测的基础，提出了应用邻近像素点灰度差值概念，从而进行判断是否为角点、边缘、平滑区域。Harris角点检测原理是利用移动的窗口在图像中计算灰度变化值，其中关键流程包括转化为灰度图像、计算差分图像、高斯平滑、计算局部极值、确认角点。算法的核心是利用局部窗口在图像上进行移动判断灰度发生较大的变化。了解了算法的思想就可以构建数学模型了。这里的w是窗口函数，一般有两种选择，括号里第一项是平移后图像灰度，第二项是原图像灰度。这里我们选取的窗口移动是非常小的变化，所以u，v都很小。这时候就对括号内第一项泰勒展开化简原式。结果如下：这是一个二阶近似值，其中M可由原图上的点求梯度得到。原图求梯度后得到的图像长这个模样：从上面得到的式子可以看出，通过E来判断点的特征等价于用M来判断，而对于一个矩阵，首先想到求特征值。然后有人聪明地发现了这样的关系：于是聪明地提出了这样一个容易编程实现的函数：R取决于M的特征值，对于角点|R|很大，平坦的区域|R|很小，边缘的R为负值。算出R之后还需要进行非极大值抑制（NMS），主要是为了更精确的定位特征。上代码，不自己实现了，直接用opencv。opencv中的Harris检测方法使用函数 cv2.cornerHarris()参数如下： img 输入图像，数据类型为float32 blockSize 角点检测当中的邻域值。 ksize 使用Sobel函数求偏导的窗口大小 k 角点检测参数，取值为0.04到0.0612345678910111213141516import cv2import numpy as npfilename = '5.jpeg'img = cv2.imread(filename)gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)gray = np.float32(gray)#图像转换为float32dst = cv2.cornerHarris(gray,5,5,0.06)#图像膨胀, 让角点看起来明显点dst = cv2.dilate(dst,None)#这里的打分值以大于0.01×dst中最大值为边界， 理论上阈值越低越精确img[dst&gt;0.01*dst.max()]=[0,0,255]#角点位置用红色标记cv2.imwrite('dst2.jpeg',img) 看起来效果还不错。还试了像素更高的图片，会有很多冗余，猜测是因为噪点的缘故。opencv还提供了一个函数cv2.cornerSubPix()进行亚像素级别的角点检测，就是说精确度会更高。感觉不太好用。 尺度空间What自然界中进行度量或观测时有许多不同的表现形态。比如度量身高用“米”，观测微粒用“纳米”或者“微米”。更形象的例子比如Google地图，滑动鼠标轮可以改变观测地图的尺度，看到的地图绘制也不同；还有电影中的拉伸镜头等等……简而言之，从人眼的角度，尺度越大图像越模糊。关于尺度的意义，有一张好玩的图，在不同尺度下能看出不同的结果。 Why对尺度空间研究的意义在于用机器视觉系统分析未知场景时，计算机并不预先知道图像中物体的尺度。我们需要同时考虑图像在多尺度下的描述，获知感兴趣物体的最佳尺度。另外如果不同的尺度下都有同样的关键点，那么在不同的尺度的输入图像下就都可以检测出来关键点匹配，也就是尺度不变性。图像的尺度空间表达就是图像在所有尺度下的描述。 尺度空间与图像金字塔区别尺度空间是多尺度，图像金字塔是多分辨率。尺度空间表达和图像金字塔表达之间的不同具体说来是： （1）尺度空间表达是由不同高斯核平滑卷积得到，在所有尺度上有相同的分辨率； （2）金字塔多分辨率表达每层分辨率减少固定比率。 LoG(Laplacian of Gaussian)和DoG(Difference of Gaussian)算子高斯平滑滤波高斯核是唯一可以产生多尺度空间的核（《Scale-space theory: A basic tool for analysing structures at different scales》）。一个图像的尺度空间L(x,y,σ) ,定义为原始图像I(x,y)与一个可变尺度的2维高斯函数G(x,y,σ)卷积运算。这个算子用来去噪效果很不错的，当然要选择合适尺度的高斯滤波器，否则整个图像会变模糊。说到去噪滤波器的话还有好几个别的：这里面应该要属中值滤波器鲁棒性最好，效果也最好。扯远了，二维空间高斯函数：很显然这个函数是圆对称的，且卷积的结果使原始像素值有最大的权重，距离中心越远的相邻像素值权重也越小。高斯模糊另一个重要的性质就是线性可分，使用二维矩阵变换的高斯模糊可以通过在水平和竖直方向各进行一维高斯矩阵变换相加得到。 LoGLaplace算子通过对图像求取二阶导数的零交叉点(zero-cross)来进行边缘检测，因为在边缘处一阶导取到一个极大值，而二阶导则会与横轴相交。由于微分运算对噪声比较敏感，可以先对图像进行高斯平滑滤波，再使用Laplace算子进行边缘检测，以降低噪声的影响。由此便形成了用于极值点检测的LoG算子。顾名思义，LoG就是对高斯函数作用一个拉普拉斯算子得到的算子：草稿纸推了一下：在OpenCV-Python中，Laplace算子的函数原型如下：dst = cv2.Laplacian(src, ddepth[, dst[, ksize[, scale[, delta[, borderType]]]]])参数作用分别如下： dst是滤波之后的图像。 第一个参数是需要处理的图像。 第二个参数是图像的深度，-1表示采用的是与原图像相同的深度。目标图像的深度必须大于等于原图像的深度。 ksize是算子的大小，必须为1、3、5、7。默认为1。 scale是缩放导数的比例常数，默认情况下没有伸缩系数。 delta是一个可选的增量，将会加到最终的dst中，同样，默认情况下没有额外的值加到dst中。 borderType是判断图像边界的模式。这个参数默认值为cv2.BORDER_DEFAULT。Code:12345678import cv2img = cv2.imread("5.jpeg", 0)gray_lap = cv2.Laplacian(img,cv2.CV_16S,ksize = 3)dst = cv2.convertScaleAbs(gray_lap)cv2.imwrite('laplacian.jpeg',dst) 效果如下： DoG下面是LoG和DoG的公式：LoG计算可以利用DoG来近似，其中差分是由两个高斯滤波与不同变量的卷积结果逼近求得。证明如下：看到另一个好玩的近似：从滤波器的角度来理解，高斯滤波器是低通滤波器，两个低通滤波器的差可以构成一个带通滤波器（LoG是带通滤波器）。从函数图像上来看两种方法也是非常接近了。但是用差分的方法明显在计算上要简单很多。DoG的效果如下：当然DoG并不止是简单的一个近似，作为一个增强算法，DOG可以被用来增加边缘和其他细节的可见性，大部分的边缘算子使用增强高频信号的方法，但是因为随机噪声也是高频信号，很多锐化算子也增强了噪声。DOG算法去除的高频信号中通常包含了随机噪声，所以这种方法是最适合处理那些有高频噪声的图像。这个算法的一个主要缺点就是在调整图像对比度的过程中信息量会减少。当它被用于图像增强时，DoG算法中两个高斯核的半径之比通常为4:1或5:1。当k设为1.6时，即为高斯拉普拉斯算子的近似。高斯拉普拉斯算子在多尺度多分辨率像片中，用于近似高斯拉普拉斯算子两个高斯核的确切大小决定了两个高斯模糊后的影像间的尺度。DoG也被用于尺度不变特征变换中的斑点检测。事实上，DoG算法作为两个多元正态分布的差通常总额为零，把它和一个恒定信号进行卷积没有意义。当K约等于1.6时它很好的近似了高斯拉普拉斯变换，当K约等于5时又很好的近似了视网膜上神经节细胞的视野。它可以很好的作为一个实时斑点检测算子和尺度选择算子应用于递归程序。 引用http://www.cnblogs.com/polly333/p/5416172.htmlhttp://blog.csdn.net/xiaowei_cqu/article/details/8067881https://senitco.github.io/2017/06/20/image-feature-LoG-DoG/http://skystarry.cn/index.php/2017/04/20/dog/]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Computer Vision</tag>
        <tag>Point detection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow学习笔记5(DNN与CIFAR10）]]></title>
    <url>%2F2018%2F03%2F10%2FTensorflow5%2F</url>
    <content type="text"><![CDATA[Alexnet说好了不说神经网络的内容，但是Alexnet确实太经典太重要了，可以说这一波AI的崛起就是从这个模型开始的，还是得说两句。ImageNet Classification with Deep Convolutional Neural Networks是Hinton和他的学生Alex Krizhevsky在12年ImageNet Challenge使用的模型结构，刷新了Image Classification的几率，从此deep learning在Image这块开始一次次超过state-of-art，甚至于搭到打败人类的地步。先看看Alexnet的创新点： Data Augmentation最简单有效的提高结果，防止过拟合的方法。常用的方法有，几何特征方面：水平翻转、随机剪裁、平移变换；颜色纹理方面：颜色光照变换，如增加减少亮度，一些滤光算法等等之类的。 DropoutDropout是一种防止神经网络过拟合的方法。在每次训练中，按照一定比例抛弃一些神经元直到本次训练结束。这可以理解为每次训练一些不同的神经网络（因为不同的神经元组合会构成不同的网络）。最后通过多个网络结合的方式达到类似集成学习的效果。 LRN使用ReLU f(x)=max(0,x)后，你会发现激活函数之后的值没有了tanh、sigmoid函数那样有一个值域区间，所以一般在ReLU之后会做一个normalization，LRU就是文中提出（这里不确定，应该是提出？）一种方法，在神经科学中有个概念叫“Lateral inhibition”，讲的是活跃的神经元对它周边神经元的影响。不过后来有人说这种方法其实没有用，反正现在都用Batch normalisation来取代他了。 ReLU之前的激活函数如sigmoid，tanh，都会在取值过大或者过小的时候梯度开始趋于0，这非常不利于网络的训练，会加剧梯度消失，而且使得网络的训练速度变慢。用RELU以后偏离的信息能更快更完整地从后向前传播到整个网络。简单说收敛速度变快了。不过这种方法也有一个缺点就是，Dead ReLU Problem（神经元坏死现象），就是那些在负数部分梯度为0的神经元不会被用到。再看看结构图：alexnet总共包括8层，其中前5层convolutional，后面3层是full-connected，文章里面说的是减少任何一个卷积结果会变得很差，下面我来具体讲讲每一层的构成： 第一层卷积层 输入图像为2272273(paper上貌似有点问题2242243)的图像，使用了96个kernels（96,11,11,3），以4个pixel为一个单位来右移或者下移，能够产生5555个卷积后的矩形框值，然后进行response-normalized（其实是Local Response Normalized，后面我会讲下这里）和pooled之后，pool这一层好像caffe里面的alexnet和paper里面不太一样，alexnet里面采样了两个GPU，所以从图上面看第一层卷积层厚度有两部分，池化pool_size=(3,3),滑动步长为2个pixels，得到96个2727个feature。 第二层卷积层使用256个（同样，分布在两个GPU上，每个128kernels（5548）），做pad_size(2,2)的处理，以1个pixel为单位移动（感谢网友指出），能够产生2727个卷积后的矩阵框，做LRN处理，然后pooled，池化以33矩形框，2个pixel为步长，得到256个1313个features。 第三层、第四层都没有LRN和pool，第五层只有pool，其中第三层使用384个kernels（33384，pad_size=(1,1),得到3841515，kernel_size为（3，3),以1个pixel为步长，得到3841313）；第四层使用384个kernels（pad_size(1,1)得到3841515，核大小为（3，3）步长为1个pixel，得到3841313）；第五层使用256个kernels（pad_size(1,1)得到3841515，kernel_size(3,3)，得到2561313，pool_size(3，3）步长2个pixels，得到2566*6）。 全连接层： 前两层分别有4096个神经元，最后输出softmax为1000个（ImageNet），注意caffe图中全连接层中有relu、dropout、innerProduct。 Tensorflow简单实现用了一个简化版的Alexnet，也不太能叫Alexnet其实，没有用数据增强，去掉了LRN改用BN，六层卷积加上三层全连接。最后测试集上最好成绩是84%，不算理想。因为用keras有个教程能跑到94%，他用了一种新型初始化权重的方法：All you need is a good init。在搭结构的时候也是遇到了一些坑，最大的坑在于LRN。感觉它好像根本不work，导致死掉了一大片神经元，之前LRN用的少没想到那么不靠谱，果断换成BN，立马解决问题。测试这个网络用了cifar10的数据，老用mnist没什么意思。Cifar-10由60000张32*32的RGB彩色图片构成，共10个分类。50000张训练，10000张测试（交叉验证）。这个数据集最大的特点在于将识别迁移到了普适物体，而且应用于多分类（姊妹数据集Cifar-100达到100类，ILSVRC比赛则是1000类）。 数据输入首先是数据读取部分。要先到cifar10官网下载数据集，然后具体的读取方法网站上也说了，我这里又多写了一个generator，batch training的时候用。有一个要注意的地方是cifar10的label都是int，需要做一个one hot编码。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# -*- coding: utf-8 -*-import pickle as pimport numpy as npimport osfrom numpy.random import randintdef load_CIFAR_batch(filename): """ 载入cifar数据集的一个batch """ with open(filename, 'rb') as f: datadict = p.load(f, encoding='latin1') X = datadict['data'] Y = datadict['labels'] X = X.reshape(10000, 3, 32, 32).transpose(0, 2, 3, 1).astype("float") Y = np.array(Y) return X, Ydef load_CIFAR10(ROOT): """ 载入cifar全部数据 """ xs = [] ys = [] for b in range(1, 6): f = os.path.join(ROOT, 'data_batch_%d' % (b,)) X, Y = load_CIFAR_batch(f) xs.append(X) #将所有batch整合起来 ys.append(Y) Xtr = np.concatenate(xs) #使变成行向量,最终Xtr的尺寸为(50000,32,32,3) Ytr = np.concatenate(ys) del X, Y Xte, label = load_CIFAR_batch(os.path.join(ROOT, 'test_batch')) test_label = np.zeros((len(label), 10)) for i in range(len(label)): test_label[i][label[i]] = 1 return Xtr, Ytr, Xte, test_labeldef data_generator(x, y, batch_size): count = 0 loopcount = len(y) // batch_size while 1: j = randint(0, loopcount) train_data = x[j*batch_size: (j+1)*batch_size] label = y[j*batch_size: (j+1)*batch_size] train_label = np.zeros((batch_size, 10)) for i in range(batch_size): train_label[i][label[i]] = 1 yield train_data, train_label count += batch_sizeif __name__ == '__main__': # 载入CIFAR-10数据集 cifar10_dir = './cifar-10-batches-py/' X_train, y_train, X_test, y_test = load_CIFAR10(cifar10_dir) data_gen = data_generator(X_train,y_train,32) for i in range(30): a, b = next(data_gen) 模型接下来是训练的部分：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181import tensorflow as tfimport cifar10# # #读入mnist数据集# mnist = input_data.read_data_sets("MNIST_data/", one_hot=True)# 载入CIFAR-10数据集#label are one_hot encodedcifar10_dir = './cifar-10-batches-py/'X_train, y_train, X_test, y_test = cifar10.load_CIFAR10(cifar10_dir)#create data generatortrain_generator = cifar10.data_generator(X_train, y_train, 256)test_generator = cifar10.data_generator(X_test, y_test, 1024)#Hyperparameterslearning_rate = 0.001batch_size = 256dropout = 0.5training_iters = 100000display_step = 50#paramslength = 32width = 32dimension = 3n_classes = 10#iox = tf.placeholder('float', [None, length, width, dimension])y = tf.placeholder('float', [None, n_classes])keep_prob = tf.placeholder(tf.float32)#kernel sizeweights = &#123; 'c1': tf.Variable(tf.truncated_normal([3,3,3,64], stddev=0.001, name='wc1')), 'c2': tf.Variable(tf.truncated_normal([3,3,64,64], stddev=0.01, name='wc2')), 'c3': tf.Variable(tf.truncated_normal([3,3,64,128], stddev=0.01, name='wc3')), 'c4': tf.Variable(tf.truncated_normal([3,3,128,128], stddev=0.1, name='wc4')), 'c5': tf.Variable(tf.truncated_normal([3,3,128,256], stddev=0.1, name='wc5')), 'c6': tf.Variable(tf.truncated_normal([3,3,256,256], stddev=0.1, name='wc6')), 'f1': tf.Variable(tf.truncated_normal([4*4*256, 1024], stddev=0.01, name='fc1')), 'f2': tf.Variable(tf.truncated_normal([1024, 128], stddev=0.1, name='fc2')), 'f3': tf.Variable(tf.truncated_normal([128, 10], stddev=0.1, name='fc3'))&#125;biases = &#123; 'c1': tf.Variable(tf.constant(0.01, shape=[64], name='bc1')), 'c2': tf.Variable(tf.constant(0.01, shape=[64], name='bc2')), 'c3': tf.Variable(tf.constant(0.01, shape=[128], name='bc3')), 'c4': tf.Variable(tf.constant(0.1, shape=[128], name='bc4')), 'c5': tf.Variable(tf.constant(0.1, shape=[256], name='bc5')), 'c6': tf.Variable(tf.constant(0.1, shape=[256], name='bc6')), 'f1': tf.Variable(tf.constant(0.1, shape=[1024], name='fc1')), 'f2': tf.Variable(tf.constant(0.1, shape=[128], name='fc1')), 'f3': tf.Variable(tf.constant(0.1, shape=[10], name='fc1'))&#125;#funcsdef conv2d(input, kernel, bias, name): wx_plus_b = tf.nn.bias_add(tf.nn.conv2d(input, kernel, strides=[1,1,1,1], padding='SAME'), bias) batch_norm = bn_layer(wx_plus_b, True, name) return tf.nn.relu(batch_norm, name=name)def pooling(input, k, name): return tf.nn.max_pool(input, ksize=[1,k,k,1], strides=[1,k,k,1], padding='SAME', name=name)def lrn(input, name, lsize=5): return tf.nn.lrn(input, lsize, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name=name)# 实现Batch Normalizationdef bn_layer(x,is_training,name,moving_decay=0.9,eps=1e-5): # 获取输入维度并判断是否匹配卷积层(4)或者全连接层(2) shape = x.shape assert len(shape) in [2,4] param_shape = shape[-1] with tf.variable_scope(name): # 声明BN中唯一需要学习的两个参数，y=gamma*x+beta gamma = tf.get_variable('gamma',param_shape,initializer=tf.constant_initializer(1)) beta = tf.get_variable('beat', param_shape,initializer=tf.constant_initializer(0)) # 计算当前整个batch的均值与方差 axes = list(range(len(shape)-1)) batch_mean, batch_var = tf.nn.moments(x,axes,name='moments') # 采用滑动平均更新均值与方差 ema = tf.train.ExponentialMovingAverage(moving_decay) def mean_var_with_update(): ema_apply_op = ema.apply([batch_mean,batch_var]) with tf.control_dependencies([ema_apply_op]): return tf.identity(batch_mean), tf.identity(batch_var) # 训练时，更新均值与方差，测试时使用之前最后一次保存的均值与方差 mean, var = tf.cond(tf.equal(is_training,True),mean_var_with_update, lambda:(ema.average(batch_mean),ema.average(batch_var))) # 最后执行batch normalization return tf.nn.batch_normalization(x,mean,var,beta,gamma,eps)def fc_layer(input, weight, bias, name, batch_norm = True): wx_plus_b = tf.matmul(input, weight) + bias if batch_norm: wx_plus_b = bn_layer(wx_plus_b, True, name) return tf.nn.relu(wx_plus_b, name=name)#modeldef alexnet(X, weights, biases, dropout): # X = tf.reshape(X, [-1, 28, 28, 1]) #conv1 conv1 = conv2d(X, weights['c1'], biases['c1'], 'conv1') # pool1 = pooling(conv1, 2, 'pool1') norm1 = tf.nn.dropout(conv1, dropout) # conv2 conv2 = conv2d(norm1, weights['c2'], biases['c2'], 'conv2') pool2 = pooling(conv2, 2, 'pool2') norm2 = tf.nn.dropout(pool2, dropout) # conv3 conv3 = conv2d(norm2, weights['c3'], biases['c3'], 'conv3') # pool3 = pooling(conv3, 2, 'pool3') norm3 = tf.nn.dropout(conv3, dropout) # conv4 conv4 = conv2d(norm3, weights['c4'], biases['c4'], 'conv4') pool4 = pooling(conv4, 2, 'pool4') norm4 = tf.nn.dropout(pool4, dropout) # conv5 conv5 = conv2d(norm4, weights['c5'], biases['c5'], 'conv5') # pool5 = pooling(conv5, 2, 'pool5') norm5 = tf.nn.dropout(conv5, dropout) # conv6 conv6 = conv2d(norm5, weights['c6'], biases['c6'], 'conv6') pool6 = pooling(conv6, 2, 'pool6') norm6 = tf.nn.dropout(pool6, dropout) #fc fc1 = tf.reshape(norm6, [-1, weights['f1'].get_shape().as_list()[0]]) fc1 = fc_layer(fc1, weights['f1'], biases['f1'], 'fc1') fc2 = fc_layer(fc1, weights['f2'], biases['f2'], 'fc2') fc3 = fc_layer(fc2, weights['f3'], biases['f3'], 'fc3', batch_norm=False) return fc3#construct modelmodel = alexnet(x, weights, biases, keep_prob)#learnloss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=y, logits=model))optimizer = tf.train.AdamOptimizer(learning_rate=learning_rate).minimize(loss)correct_prediction = tf.equal(tf.argmax(model,1), tf.argmax(y,1))accuracy = tf.reduce_mean(tf.cast(correct_prediction, "float"))#initinit = tf.initialize_all_variables()#run!with tf.Session() as sess: sess.run(init) step = 0 # Keep training until reach max iterations while step &lt; training_iters: batch_xs, batch_ys = next(train_generator) # get batch data sess.run(optimizer, feed_dict=&#123;x: batch_xs, y: batch_ys, keep_prob: dropout&#125;) if step % display_step == 0: # Train acc acc = sess.run(accuracy, feed_dict=&#123;x: batch_xs, y: batch_ys, keep_prob: 1.&#125;) # train loss loss_val = sess.run(loss, feed_dict=&#123;x: batch_xs, y: batch_ys, keep_prob: 1.&#125;) print ("Iter " + str(step) + ", Minibatch Loss= " + "&#123;:.6f&#125;".format(loss_val) + ", Training Accuracy= " + "&#123;:.5f&#125;".format(acc)) #Test acc if step % 1000 == 0: batch_x, batch_y = next(test_generator) print("Testing Accuracy:", sess.run(accuracy, feed_dict=&#123;x: batch_x, y: batch_y, keep_prob: 1.&#125;)) step += 1 print ("Optimization Finished!") VGG16 and so on…至于VGG16以及inception，Googlenet，其实就是不断加深网络的层数，用了一些小trick，实现起来大同小异，就不多写了。VGG16的实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#kernel sizeweights = &#123; 'c11': tf.Variable(tf.truncated_normal([3,3,3,64], stddev=0.001, name='wc11')), 'c12': tf.Variable(tf.truncated_normal([3,3,64,64], stddev=0.001, name='wc12')), 'c21': tf.Variable(tf.truncated_normal([3,3,64,128], stddev=0.001, name='wc21')), 'c22': tf.Variable(tf.truncated_normal([3,3,128,128], stddev=0.01, name='wc22')), 'c31': tf.Variable(tf.truncated_normal([3,3,128,256], stddev=0.01, name='wc31')), 'c32': tf.Variable(tf.truncated_normal([3,3,256,256], stddev=0.01, name='wc32')), 'c33': tf.Variable(tf.truncated_normal([3,3,256,256], stddev=0.01, name='wc33')), 'c41': tf.Variable(tf.truncated_normal([3,3,256,512], stddev=0.01, name='wc41')), 'c42': tf.Variable(tf.truncated_normal([3,3,512,512], stddev=0.01, name='wc42')), 'c43': tf.Variable(tf.truncated_normal([3,3,512,512], stddev=0.01, name='wc43')), 'c51': tf.Variable(tf.truncated_normal([3,3,512,512], stddev=0.1, name='wc51')), 'c52': tf.Variable(tf.truncated_normal([3,3,512,512], stddev=0.1, name='wc52')), 'c53': tf.Variable(tf.truncated_normal([3,3,512,512], stddev=0.1, name='wc53')), 'f1': tf.Variable(tf.truncated_normal([8*7*512, 2048], stddev=0.01, name='fc1')), 'f2': tf.Variable(tf.truncated_normal([2048, 1024], stddev=0.1, name='fc2')), 'f3': tf.Variable(tf.truncated_normal([1024, 2], stddev=0.1, name='fc3'))&#125;biases = &#123; 'c11': tf.Variable(tf.constant(0.01, shape=[64], name='bc11')), 'c12': tf.Variable(tf.constant(0.01, shape=[64], name='bc12')), 'c21': tf.Variable(tf.constant(0.01, shape=[128], name='bc21')), 'c22': tf.Variable(tf.constant(0.1, shape=[128], name='bc22')), 'c31': tf.Variable(tf.constant(0.01, shape=[256], name='bc31')), 'c32': tf.Variable(tf.constant(0.01, shape=[256], name='bc32')), 'c33': tf.Variable(tf.constant(0.1, shape=[256], name='bc32')), 'c41': tf.Variable(tf.constant(0.01, shape=[512], name='bc41')), 'c42': tf.Variable(tf.constant(0.01, shape=[512], name='bc42')), 'c43': tf.Variable(tf.constant(0.1, shape=[512], name='bc42')), 'c51': tf.Variable(tf.constant(0.01, shape=[512], name='bc51')), 'c52': tf.Variable(tf.constant(0.01, shape=[512], name='bc52')), 'c53': tf.Variable(tf.constant(0.1, shape=[512], name='bc52')), 'f1': tf.Variable(tf.constant(0.1, shape=[2048], name='fc1')), 'f2': tf.Variable(tf.constant(0.1, shape=[1024], name='fc1')), 'f3': tf.Variable(tf.constant(0.1, shape=[2], name='fc1'))&#125;#funcsdef conv2d(input, kernel, bias, name): wx_plus_b = tf.nn.bias_add(tf.nn.conv2d(input, kernel, strides=[1,1,1,1], padding='SAME'), bias) batch_norm = bn_layer(wx_plus_b, True, name) return tf.nn.relu(batch_norm, name=name)def pooling(input, k, name): return tf.nn.max_pool(input, ksize=[1,k,k,1], strides=[1,k,k,1], padding='SAME', name=name)# 实现Batch Normalizationdef bn_layer(x,is_training,name,moving_decay=0.9,eps=1e-3): # 获取输入维度并判断是否匹配卷积层(4)或者全连接层(2) shape = x.shape assert len(shape) in [2,4] param_shape = shape[-1] with tf.variable_scope(name): # 声明BN中唯一需要学习的两个参数，y=gamma*x+beta gamma = tf.get_variable('gamma',param_shape,initializer=tf.constant_initializer(1)) beta = tf.get_variable('beat', param_shape,initializer=tf.constant_initializer(0)) # 计算当前整个batch的均值与方差 axes = list(range(len(shape)-1)) batch_mean, batch_var = tf.nn.moments(x,axes,name='moments') # 采用滑动平均更新均值与方差 ema = tf.train.ExponentialMovingAverage(moving_decay) def mean_var_with_update(): ema_apply_op = ema.apply([batch_mean,batch_var]) with tf.control_dependencies([ema_apply_op]): return tf.identity(batch_mean), tf.identity(batch_var) # 训练时，更新均值与方差，测试时使用之前最后一次保存的均值与方差 mean, var = tf.cond(tf.equal(is_training,True),mean_var_with_update, lambda:(ema.average(batch_mean),ema.average(batch_var))) # 最后执行batch normalization return tf.nn.batch_normalization(x,mean,var,beta,gamma,eps)def fc_layer(input, weight, bias, name, batch_norm = True): wx_plus_b = tf.matmul(input, weight) + bias if batch_norm: wx_plus_b = bn_layer(wx_plus_b, True, name) return tf.nn.sigmoid(wx_plus_b, name=name)#modeldef vgg16(X, weights, biases, dropout): # block 1 conv1_1 = conv2d(X, weights['c11'], biases['c11'], 'conv11') conv1_2 = conv2d(conv1_1, weights['c12'], biases['c12'], 'conv12') pool1 = pooling(conv1_2, 2, 'pool1') drop1 = tf.nn.dropout(pool1, dropout) # block 2 conv2_1 = conv2d(drop1, weights['c21'], biases['c21'], 'conv21') conv2_2 = conv2d(conv2_1, weights['c22'], biases['c22'], 'conv22') pool2 = pooling(conv2_2, 2, 'pool2') drop2 = tf.nn.dropout(pool2, dropout) # block 3 conv3_1 = conv2d(drop2, weights['c31'], biases['c31'], 'conv31') conv3_2 = conv2d(conv3_1, weights['c32'], biases['c32'], 'conv32') conv3_3 = conv2d(conv3_2, weights['c33'], biases['c33'], 'conv33') pool3 = pooling(conv3_3, 2, 'pool3') drop3 = tf.nn.dropout(pool3, dropout) # block 4 conv4_1 = conv2d(drop3, weights['c41'], biases['c41'], 'conv41') conv4_2 = conv2d(conv4_1, weights['c42'], biases['c42'], 'conv42') conv4_3 = conv2d(conv4_2, weights['c43'], biases['c43'], 'conv43') pool4 = pooling(conv4_3, 2, 'pool4') drop4 = tf.nn.dropout(pool4, dropout) # block 5 conv5_1 = conv2d(drop4, weights['c51'], biases['c51'], 'conv51') conv5_2 = conv2d(conv5_1, weights['c52'], biases['c52'], 'conv52') conv5_3 = conv2d(conv5_2, weights['c53'], biases['c53'], 'conv53') pool5 = pooling(conv5_3, 2, 'pool5') drop5 = tf.nn.dropout(pool5, dropout) #fc fc1 = tf.reshape(drop5, [-1, weights['f1'].get_shape().as_list()[0]]) fc1 = fc_layer(fc1, weights['f1'], biases['f1'], 'fc1') fc2 = fc_layer(fc1, weights['f2'], biases['f2'], 'fc2') fc3 = fc_layer(fc2, weights['f3'], biases['f3'], 'fc3', batch_norm=False) return fc3 基本上和Alexnet一样的。 #Next接下来写个fine tuning的。 引用https://zhuanlan.zhihu.com/p/30486789http://www.cnblogs.com/52machinelearning/p/5821591.html]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些动人的诗词]]></title>
    <url>%2F2018%2F03%2F09%2Fpoem%2F</url>
    <content type="text"><![CDATA[江夏别宋之悌.李白平生不下泪，于此泣无穷。 浪淘沙.欧阳修把酒祝东风，且共从容，垂杨紫陌洛城东。总是当时携手处，游遍芳丛。聚散苦匆匆，此恨无穷。今年花胜去年红。可惜明年花更好，知与谁同？ 无门关.慧开禅师春有百花秋有月，夏有凉风冬有雪。 秋夜寄僧.欧阳詹遥知是夜檀溪上，月照千峰为一人。 浣溪沙·一向年光有限身.晏殊一向年光有限身，等闲离别易销魂，酒筵歌席莫辞频。满目山河空念远，落花风雨更伤春，不如怜取眼前人。 云南某烟盒与君初相见，犹如故人归。 长恨歌.白居易玉容寂寞泪阑干，梨花一枝春带雨。 北大女生节幸得识卿桃花面，从此阡陌多暖春。 菩萨蛮其三.韦庄如今却忆江南乐，当时年少春衫薄。骑马倚斜桥，满楼红袖招。 题龙阳县青草湖.唐温如西风吹老洞庭波，一夜湘君白发多。醉后不知天在水，满船清梦压星河。 留侯论.苏轼古人所谓豪杰之士者，必有过人之节。人情有所不能忍者，匹夫见辱，拔剑而起，挺身而斗，此不足为勇也。天下有大勇者，卒然临之而不惊。无故加之而不怒；此其所挟持者甚大，而其志甚远也。 石家小鬼严冬思暖夏，梦回满繁花。 青杏儿.赵秉文风雨替花愁。风雨罢，花也应休。劝君莫惜花前醉，今年花谢，明年花谢，白了人头。乘兴两三瓯。拣溪山好处追游。但教有酒身无事，有花也好，无花也好，选甚春秋。 吴越王妃每岁春必归临安，王以书遗妃曰：陌上花开，可缓缓归矣。 鹧鸪天· 纳兰性德别绪如丝睡不成，那堪孤枕梦边城。因听紫塞三更雨，却忆红楼半夜灯。书郑重，恨分明，天将愁味酿多情。起来呵手封题处，偏到鸳鸯两字冰。 鹧鸪天.晏几道彩袖殷勤捧玉钟，当年拚却醉颜红。舞低杨柳楼心月，歌尽桃花扇底风。从别后，忆相逢，几回魂梦与君同。今宵剩把银釭照，犹恐相逢是梦中。 国风·唐风·绸缪绸缪束薪，三星在天。今夕何夕，见此良人？子兮子兮，如此良人何。 唐多令·芦叶满汀洲.辛弃疾欲买桂花同载酒，终不似，少年游。 春山夜月.于良史掬水月在手，弄花香满衣。 菩萨蛮.温庭筠小山重叠金明灭，鬓云欲度香腮雪。懒起画蛾眉，弄妆梳洗迟。照花前后镜，花面交相映。新帖绣罗襦，双双金鹧鸪。]]></content>
      <categories>
        <category>古诗词</category>
      </categories>
      <tags>
        <tag>无病呻吟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow学习笔记4(Tensorboard与可视化）]]></title>
    <url>%2F2018%2F03%2F09%2FTensorflow4%2F</url>
    <content type="text"><![CDATA[Tensorboard的可视化过程（1）首先肯定是先建立一个graph,你想从这个graph中获取某些数据的信息（2）确定要在graph中的哪些节点放置summary operations以记录信息使用tf.summary.scalar记录标量使用tf.summary.histogram记录数据的直方图使用tf.summary.distribution记录数据的分布图使用tf.summary.image记录图像数据（3）operations并不会去真的执行计算，除非你告诉他们需要去run,或者它被其他的需要run的operation所依赖。而我们上一步创建的这些summary operations其实并不被其他节点依赖，因此，我们需要特地去运行所有的summary节点。但是呢，一份程序下来可能有超多这样的summary 节点，要手动一个一个去启动自然是及其繁琐的，因此我们可以使用tf.summary.merge_all去将所有summary节点合并成一个节点，只要运行这个节点，就能产生所有我们之前设置的summary data。（4）使用tf.summary.FileWriter将运行后输出的数据都保存到本地磁盘中（5）运行整个程序，并在终端输入运行tensorboard的指令（tensorboard –logdir logs所在文件夹）。执行成功应该能看到TensorBoard 1.6.0 at http://你的电脑名字:6006 (Press CTRL+C to quit)。之后打开web端可查看可视化的结果。 举个栗子用的还是上一次分类mnist的cnn，但是注意在变量的声明阶段要加上name_scope。声明变量时加的tf.summary.histogram，可以让我们在最后看到训练过程中变量统计直方图的变化。加了一层卷积的目的是为了把特征减少到4个，用tf.summary.image看看卷积网络提取的特征长什么样子（结果也看不出来什么）。因为tf.summary.image只能存储1,3,4维特征的tensor，就是说tensor的第四个数必须是1,3,4之一。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from tensorflow.examples.tutorials.mnist import input_dataimport tensorflow as tfdef weight_variable(shape, name): initial = tf.truncated_normal(shape, stddev=0.1, name=name) return tf.Variable(initial)def bias_variable(shape, name): initial = tf.constant(0.1, shape=shape, name=name) return tf.Variable(initial)# 读入mnist数据集mnist = input_data.read_data_sets("MNIST_data/", one_hot=True)# 变量声明# define placeholder for inputs to networkwith tf.name_scope('inputs'): x = tf.placeholder('float', [None, 784], name='x_input') # None 为了留给后面的batch_size y_ = tf.placeholder('float', [None, 10], name='y_input')with tf.name_scope('conv1'): with tf.name_scope('weights'): W_conv1 = weight_variable([5, 5, 1, 32], name='W1') tf.summary.histogram('conv1/weights', W_conv1) with tf.name_scope('bias'): b_conv1 = bias_variable([32], name='B1') tf.summary.histogram('conv1/bias', b_conv1)with tf.name_scope('conv2'): with tf.name_scope('weights'): W_conv2 = weight_variable([5, 5, 32, 64], name='W2') tf.summary.histogram('conv2/weights', W_conv2) with tf.name_scope('bias'): b_conv2 = bias_variable([64], name='B2') tf.summary.histogram('conv2/bias', b_conv2)with tf.name_scope('conv3'): with tf.name_scope('weights'): W_conv3 = weight_variable([5, 5, 64, 4], name='W3') tf.summary.histogram('conv2/weights', W_conv3) with tf.name_scope('bias'): b_conv3 = bias_variable([4], name='B3') tf.summary.histogram('conv3/bias', b_conv3)with tf.name_scope('fc1'): with tf.name_scope('weights'): W_fc1 = weight_variable([7 * 7 * 4, 1024], name='w1') tf.summary.histogram('fc1/weights', W_fc1) with tf.name_scope('bias'): b_fc1 = bias_variable([1024], name='b1') tf.summary.histogram('fc1/weights', b_fc1)with tf.name_scope('fc2'): with tf.name_scope('weights'): W_fc2 = weight_variable([1024, 10], name='w2') tf.summary.histogram('fc2/weights', W_fc2) with tf.name_scope('bias'): b_fc2 = bias_variable([10], name='b2') tf.summary.histogram('fc2/weights', b_fc2) 接下来是计算图的部分。这里存的变量是两个image和两个scalar，其他的name_scope是为了之后在tensorboard可视化计算图用的。123456789101112131415161718192021222324252627282930313233343536# 计算图with tf.name_scope('input_reshape'): x_image = tf.reshape(x, [-1, 28, 28, 1]) tf.summary.image('input', x_image, 10)with tf.name_scope('c1'): conv1 = tf.nn.relu(tf.nn.conv2d(x_image, W_conv1, strides=[1,1,1,1], padding='SAME') + b_conv1) pool1 = tf.nn.max_pool(conv1, ksize=[1,2,2,1], strides=[1,2,2,1], padding='SAME')with tf.name_scope('c2'): conv2 = tf.nn.relu(tf.nn.conv2d(pool1, W_conv2, strides=[1,1,1,1], padding='SAME') + b_conv2) pool2 = tf.nn.max_pool(conv2, ksize=[1,2,2,1], strides=[1,2,2,1], padding='SAME')with tf.name_scope('c3'): conv3 = tf.nn.relu(tf.nn.conv2d(pool2, W_conv3, strides=[1, 1, 1, 1], padding='SAME') + b_conv3) tf.summary.image('third_conv', conv3, 10)with tf.name_scope('f1'): pool2_flat = tf.reshape(conv3, [-1, 7*7*4]) fc1 = tf.nn.relu(tf.matmul(pool2_flat,W_fc1) + b_fc1)with tf.name_scope('f2'): y = tf.nn.softmax(tf.matmul(fc1, W_fc2) + b_fc2)with tf.name_scope('loss'): loss = -tf.reduce_sum(y_ * tf.log(y)) tf.summary.scalar('loss', loss)with tf.name_scope('train'): train_step = tf.train.AdamOptimizer(1e-4).minimize(loss)correct_prediction = tf.equal(tf.argmax(y, 1), tf.argmax(y_, 1))with tf.name_scope('accuracy'): accuracy = tf.reduce_mean(tf.cast(correct_prediction, 'float')) tf.summary.scalar('accuracy', accuracy) 在训练过程中同时记录模型在训练集和测试集上的表现，所以用了两个tf.summary.FileWriter。其他的训练步骤和之前一样。1234567891011121314151617181920212223242526# 初始化变量init = tf.global_variables_initializer()#logsmerged_summary_op = tf.summary.merge_all()# 开始训练with tf.Session() as sess: sess.run(init) train_summary_writer = tf.summary.FileWriter('./logs', sess.graph) test_summary_writer = tf.summary.FileWriter('./logs', sess.graph) for i in range(1000): x_batch, y_batch = mnist.train.next_batch(50) sess.run(train_step, feed_dict=&#123;x: x_batch, y_: y_batch&#125;) if i % 100 == 0: print(sess.run(accuracy, feed_dict=&#123;x: x_batch, y_: y_batch&#125;)) #eval on train set summary_str = sess.run(merged_summary_op, feed_dict=&#123;x: x_batch, y_: y_batch&#125;) train_summary_writer.add_summary(summary_str, i) #eval on test set summary_str = sess.run(merged_summary_op, feed_dict=&#123;x: mnist.test.images, y_: mnist.test.labels&#125;) test_summary_writer.add_summary(summary_str, i) print ("test accuracy %g"%accuracy.eval(feed_dict=&#123; x: mnist.test.images, y_: mnist.test.labels&#125;)) Tensorboard Web端 SCALAR展示的是标量的信息，我程序中用tf.summary.scalars()定义的信息都会在这个窗口。回顾本文程序中定义的标量有：准确率accuracy,dropout的保留率，隐藏层中的参数信息，已经交叉熵损失。这些都在SCLARS窗口下显示出来了。展示的是标量的信息，我程序中用tf.summary.scalars()定义的信息都会在这个窗口。程序中定义的标量有：accuracy, loss。这些都在SCALARS窗口下显示出来了。老实说要看这两个用tensorboard有点大材小用，有非常方便的解决方案。 IMAGES在程序中我们设置了一处保存了图像信息，就是在转变了输入特征的shape，然后记录到了image中，于是在tensorflow中就会还原出原始的图片了：原始图片28×28×1：经过三层卷积后774, 这个已经看不出特征了，也许该想个更好的方法。或者这时候特征已经比较抽象： GRAPHS这里展示的是整个训练过程的计算图graph,从中我们可以清洗地看到整个程序的逻辑与过程。对于比较深或者结构比较复杂的神经网络，这个工具用来做可视化还是很方便的。单击某个节点，可以查看属性，输入，输出等信息 DISTRIBUTIONS这里查看的是神经元输出的分布，有激活函数之前的分布，激活函数之后的分布等。 HISTOGRAMS也可以看以上保存的变量的直方图。 引用http://blog.csdn.net/u012052268/article/details/75394077http://blog.csdn.net/sinat_33761963/article/details/62433234]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow学习笔记3(mnist和cnn)]]></title>
    <url>%2F2018%2F03%2F08%2FTensorflow3%2F</url>
    <content type="text"><![CDATA[MNIST数据集简而言之就是手写数字识别，在所有教程里面都会把这个拿来入门用。这里记录一下自己用fc和CNN在tensorflow上的代码。结果就不重要了，主要为了练手。 读入数据直接从tf模块里读入mnist1234from tensorflow.examples.tutorials.mnist import input_dataimport tensorflow as tf#读入mnist数据集mnist = input_data.read_data_sets("MNIST_data/", one_hot=True) 一层全连接网络12345678910111213141516171819202122232425#变量声明x = tf.placeholder('float',[None, 784]) #None 为了留给后面的batch_sizey = tf.placeholder('float',[None, 10])W = tf.Variable(tf.zeros([784,10]))b = tf.Variable(tf.zeros([10]))#计算图y = tf.nn.softmax(tf.matmul(x, W)+b)loss = -tf.reduce_sum(y_*tf.log(y))train_step = tf.train.AdamOptimizer(0.01).minimize(loss)correct_prediction = tf.equal(tf.argmax(y,1), tf.argmax(y_,1))accuracy = tf.reduce_mean(correct_prediction, 'float')#初始化变量init = tf.global_variables_initializer()# 开始训练with tf.Session() as sess: sess.run(init) for i in range(1000): x_batch, y_batch = mnist.train.next_batch(50) sess.run(train_step, feed_dict=&#123;x: x_batch, y_: y_batch&#125;) if i % 100 == 0: print(sess.run(accuracy, feed_dict=&#123;x: x_batch, y_: y_batch&#125;))#测试 print ("test accuracy %g"%accuracy.eval(feed_dict=&#123; x: mnist.test.images, y_: mnist.test.labels&#125;)) 卷积网络原理和结构很简单，但是自己写还是容易错，写一遍就当复习了。也是有段时间没有写tf底层的结构了。初始化变量，这里用了两层卷积加两层fc，最后softmax分类。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 变量声明#输入输出占位变量x = tf.placeholder('float', [None, 784]) # None 为了留给后面的batch_sizey_ = tf.placeholder('float', [None, 10])#这里是两层卷积，都用5*5卷积核w_conv1 = tf.Variable(tf.truncated_normal([5,5,1,32], stddev=0.1))b1 = tf.Variable(tf.constant(0.1, shape = [32]))w_conv2 = tf.Variable(tf.truncated_normal([5,5,32,64], stddev=0.1))b2 = tf.Variable(tf.constant(0.1, shape = [64]))#接两层全连接w_fc1 = tf.Variable(tf.truncated_normal([7*7*64, 1024], stddev=0.1))b_fc1 = tf.Variable(tf.constant(0.1, shape = [1024]))W_fc2 = tf.Variable(tf.truncated_normal([1024, 10], stddev=0.1))b_fc2 = tf.Variable(tf.constant(0.1, shape = [10]))#引入dropoutkeep_prob = tf.placeholder("float")#计算图#先把输入reshape成一个二维变量x_image = tf.reshape(x, [-1, 28, 28, 1])#第一层卷积，用relu作activationconv1 = tf.nn.relu(tf.nn.conv2d(x_image, w_conv1, strides=[1,1,1,1], padding='SAME'))pool1 = tf.nn.max_pool(conv1, ksize=[1,2,2,1], strides=[1,2,2,1], padding='SAME')#第二层卷积conv2 = tf.nn.relu(tf.nn.conv2d(pool1, w_conv2, strides=[1,1,1,1], padding='SAME'))pool2 = tf.nn.max_pool(conv2, ksize=[1,2,2,1], strides=[1,2,2,1], padding='SAME')#flatten后接到全连接层pool2_flat = tf.reshape(pool2, [-1, 7*7*64])fc1 = tf.nn.relu(tf.matmul(pool2_flat,w_fc1) + b_fc1)#最后用softmax分类y = tf.nn.softmax(tf.matmul(fc1, W_fc2) + b_fc2)#同之前的网络loss = -tf.reduce_sum(y_ * tf.log(y))train_step = tf.train.AdamOptimizer(1e-4).minimize(loss)correct_prediction = tf.equal(tf.argmax(y, 1), tf.argmax(y_, 1))accuracy = tf.reduce_mean(tf.cast(correct_prediction, 'float'))# 初始化变量init = tf.global_variables_initializer()# 开始训练with tf.Session() as sess: sess.run(init) for i in range(10000): x_batch, y_batch = mnist.train.next_batch(50) sess.run(train_step, feed_dict=&#123;x: x_batch, y_: y_batch&#125;) if i % 100 == 0: print(sess.run(accuracy, feed_dict=&#123;x: x_batch, y_: y_batch&#125;)) print ("test accuracy %g"%accuracy.eval(feed_dict=&#123; x: mnist.test.images, y_: mnist.test.labels&#125;)) 大功告成，tf还是要多写，不然容易漏东西。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow学习笔记2(变量与计算图搭建)]]></title>
    <url>%2F2018%2F03%2F08%2FTensorflow2%2F</url>
    <content type="text"><![CDATA[常量、变量和占位符在定义计算图之前要了解一下tf中变量保存的形式。TensorFlow 中最基本的单位是常量（Constant）、变量（Variable）和占位符（Placeholder）。常量定义后值和维度不可变，变量定义后值可变而维度不可变。在神经网络中，变量一般可作为储存权重和其他信息的矩阵，而常量可作为储存超参数或其他结构信息的变量。在上面的计算图中，结点 1 和结点 2 都是定义的常量 tf.constant()。我们可以分别声明不同的常量（tf.constant()）和变量（tf.Variable()），其中 tf.float和tf.int分别声明了不同的浮点型和整数型数据。通常常量用来保存计算图中可训练的数据，常量则是不可训练数据。有一点非常重要，如果一个变量没有声明是tf.Variable()，他很有可能被当成是一个常量来处理，就是说在训练过程中始终得不到优化。占位符的特点是没有初始值，它只会分配必要的内存。在会话中，占位符可以使用 feed_dict 馈送数据。占位符一般用来读取训练或者预测所用的数据，并送入图中，以及接受最后计算得到的结果。feed_dict 是一个字典，在字典中需要给出每一个用到的占位符的取值。12345678910111213import tensorflow as tfimport numpy as npa=tf.placeholder('float32', [3])b=tf.placeholder('float32', [3])c=tf.multiply(a, b)x1 = [np.random.random() for _ in range(3)]x2 = [np.random.random() for _ in range(3)]with tf.Session() as sess: print(sess.run(c, feed_dict=&#123;a:x1,b:x2&#125;)) 在初始化这些张量的时候一定要注意shape，整个计算图中只要有一个地方对不上，就会报错。 计算图TensorFlow 是一种采用数据流图（data flow graphs），用于数值计算的开源软件库。其中 Tensor 代表传递的数据为张量（多维数组），Flow 代表使用计算图进行运算。数据流图用「结点」（nodes）和「边」（edges）组成的有向图来描述数学运算。「结点」一般用来表示施加的数学操作，但也可以表示数据输入的起点和输出的终点，或者是读取/写入持久变量（persistent variable）的终点。边表示结点之间的输入/输出关系。这些数据边可以传送维度可动态调整的多维数据数组，即张量（tensor）。简单来说，计算图定义了从input到output过程中张量所经过的计算和变化。在tensorflow中用的是静态图。静态的意思就是计算图的声明和执行是分开的，我们接下来可以看到使用tf之前，整个计算的流程就已经被设计好了。这份计算图一般会包含计算执行顺序和内存空间分配的策略，这些策略的制定一般是这个过程中最消耗时间的部分；执行阶段构建的图叫实体计算图，这个过程包括为参数和中间结果实际分配内存空间，并按照当前需求进行计算等，数据就在这张实体计算图中计算和传递。而PyTorch用的则是动态图，声明和执行一起进行的。上代码：先声明需要拟合的数据，看一下他们的分布1234567891011121314151617import tensorflow as tfimport numpyimport matplotlib.pyplot as pltrng = numpy.random# Parameterslearning_rate = 0.01training_epochs = 2000display_step = 50# Training Datatrain_X = numpy.asarray([3.3,4.4,5.5,6.71,6.93,4.168,9.779,6.182,7.59,2.167,7.042,10.791,5.313,7.997,5.654,9.27,3.1])train_Y = numpy.asarray([1.7,2.76,2.09,3.19,1.694,1.573,3.366,2.596,2.53,1.221,2.827,3.465,1.65,2.904,2.42,2.94,1.3])n_samples = train_X.shape[0]plt.plot(train_X, train_Y, '.')plt.show() 这么一看大概就能画出来了。 接下来定义各种变量。12345678# tf Graph InputX = tf.placeholder("float")Y = tf.placeholder("float")# Create Model# Set model weightsW = tf.Variable(rng.randn(), name="weight")b = tf.Variable(rng.randn(), name="bias") 然后定义计算图和优化对象，这是最重要的一部分，定义张量计算的方式和传递的路径。这个模型很简单，只有一步，Y=X×W+b。定义完计算图就能通过得到结果了，这时候可以定义损失函数了，因为是线性回归，用的就是均方差。优化器是普通的梯度下降。123456# Construct a linear modelactivation = tf.add(tf.multiply(X, W), b)# Minimize the squared errorscost = tf.reduce_sum(tf.pow(activation-Y, 2))/(2*n_samples) #L2 lossoptimizer = tf.train.GradientDescentOptimizer(learning_rate).minimize(cost) #Gradient descent 在正式训练开始之前需要初始化所有变量，其实就是分配内存的过程。这在上面静态图的部分说过了。喂数据用的是feed_dict上面也写过了。就可以开始训练了。123456789101112131415161718192021222324252627# Initializing the variablesinit = tf.global_variables_initializer()# Launch the graphwith tf.Session() as sess: sess.run(init) # Fit all training data for epoch in range(training_epochs): for (x, y) in zip(train_X, train_Y): sess.run(optimizer, feed_dict=&#123;X: x, Y: y&#125;) #Display logs per epoch step if epoch % display_step == 0: print ("Epoch:", '%04d' % (epoch+1), "cost=", \ "&#123;:.9f&#125;".format(sess.run(cost, feed_dict=&#123;X: train_X, Y:train_Y&#125;)), \ "W=", sess.run(W), "b=", sess.run(b)) print("Optimization Finished!") print("cost=", sess.run(cost, feed_dict=&#123;X: train_X, Y: train_Y&#125;), \ "W=", sess.run(W), "b=", sess.run(b)) #Graphic display plt.plot(train_X, train_Y, 'ro', label='Original data') plt.plot(train_X, sess.run(W) * train_X + sess.run(b), label='Fitted line') plt.legend() plt.show() 最后的结果： 模型的保存和读取用tf.train.Saver()创建一个Saver来管理模型中的所有变量，这样的话方便下一次继续使用训练好的模型。在训练阶段最后加上一句把模型存下来。存下来的模型是一个ckpt文件，里面包含了上面定义的所有变量，所以如果重新读取使用的话要定义好计算图。12345678910111213141516171819# Launch the graphwith tf.Session() as sess: sess.run(init) # Fit all training data for epoch in range(training_epochs): for (x, y) in zip(train_X, train_Y): sess.run(optimizer, feed_dict=&#123;X: x, Y: y&#125;) #Display logs per epoch step if epoch % display_step == 0: print ("Epoch:", '%04d' % (epoch+1), "cost=", \ "&#123;:.9f&#125;".format(sess.run(cost, feed_dict=&#123;X: train_X, Y:train_Y&#125;)), \ "W=", sess.run(W), "b=", sess.run(b)) # Save the variables to disk. save_path = saver.save(sess, "./tmp/model.ckpt") print("Model saved in file: ", save_path) print("Optimization Finished!") 然后可以直接读取训练好的模型进行预测，读取网上一些训练好的模型来做迁移学习也可以这么用。12345678910111213#restore modelwith tf.Session() as sess: # Restore variables from disk. saver.restore(sess, "./tmp/model.ckpt") print("Model restored.") print("cost=", sess.run(cost, feed_dict=&#123;X: train_X, Y: train_Y&#125;), \ "W=", sess.run(W), "b=", sess.run(b)) #Graphic display plt.plot(train_X, train_Y, 'ro', label='Original data') plt.plot(train_X, sess.run(W) * train_X + sess.run(b), label='Fitted line') plt.legend() plt.show() 引用https://zhuanlan.zhihu.com/p/29936078https://zhuanlan.zhihu.com/p/25216368https://github.com/aymericdamien/TensorFlow-Examples/http://www.tensorfly.cn/tfdoc/how_tos/variables.html]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow学习笔记1(Tensor和基本计算）]]></title>
    <url>%2F2018%2F03%2F08%2FTensorflow1%2F</url>
    <content type="text"><![CDATA[Hello World创建一个session，它是tf对所有对象操作所需的基本单元。Session 是 Tensorflow 为了控制，和输出文件的执行的语句。 运行 session.run() 可以获得你要得知的运算结果, 或者是你所要运算的部分。1234import tensorflow as tfhello = tf.constant('Hello, TensorFlow!')sess = tf.Session()print sess.run(hello) TensorTensor实际上就是一个多维数组（multidimensional array），是TF的主要数据结构。它们在一个或多个由节点（nodes）和边（edges）组成的图（graphs）中流动。边代表的是tensors，节点代表的是对tensors的操作（operations，or Ops for short）。tensors在图中从一个节点流向另一个节点，每次经过一个节点都会接受一次操作。在计算机视觉的应用中，tensor一般有(dimmension, height, width)三个维度，比如一张三维256*256的图片，tensor的shape就是（3,256,256)。有时候还包含第四维batch size，用于批量学习。 创建tensor的方法可以分为2种，一种是用TF自带的一些函数直接创建，例如：12345678910111213import tensorflow as tf # create a zero filled tensor tf.zeros([row_dim, col_dim]) # create a one filled tensor tf.ones([row_dim, col_dim]) # create a constant filled tensor tf.fill([row_dim, col_dim], 42) # create a tensor out of an existing constant tf.constant([1, 2, 3]) # generate random numbers from a uniform distribution tf.random_uniform([row_dim, col_dim], minval=0, maxval=1) # generate random numbers from a normal distribution tf.random_normal([row_dim, col_dim], mean=0.0, stddev=1.0) 另一种是将Python对象（Numpy arrays， Python lists，Python scalars）转成tensor，例如：123import numpy as npx_data = np.array([[1., 2., 3.], [3., 2., 6.]])tf.convert_to_tensor(x_data, dtype=tf.float32) Tensor对象有3个属性： 一个名字，它用于键值对的存储，用于后续的检索：Const: 0 一个形状描述， 描述数据的每一维度的元素个数：（6，3，7） 数据类型，比如 float32下面举一个简单的例子来说明tensor是如何在graph中流动的：节点a接收了一个1-D tensor，该tensor从节点a流出后，分别流向了节点b和c，节点b执行的是prod操作（5*3），节点c执行的是sum操作（5+3）。当tensor从节点b流出时变成了15，从节点c流出时变成了8。此时，2个tensor又同时流入节点d，接受的是add操作（15+8），最后从节点d流出的tensor就是23。用TF代码来创建上面的graph：12345import tensorflow as tf a = tf.constant([5, 3], name='input_a') b = tf.reduce_prod(a, name='prod_b') c = tf.reduce_sum(a, name='sum_c') d = tf.add(b, c, name='add_d') 在上面的代码中，我们用不同的构造函数（constructor）定义了四个操作（对应图上4个节点）。例如，tf.constant()创建的操作实际上就是一个“二传手”：接受一个tensor（或者一个list对象，自动将其转换成tensor对象），然后传给与它直接相连的下一个node。tf.reduce_prod()和tf.reduce_sum()操作可以把input tensor对象中的所有值相乘或相加，然后传递给下一个直接相连的node。 基本运算首先是int加减乘除。12345678import tensorflow as tfa = tf.constant(2)b = tf.constant(3)#一定要在一个session下进行tf的所有计算, 或者说所有动态操作。计算图搭建的过程倒是不需要with tf.Session() as sess: print('a=%i,b=%i)%(sess.run(a),sess.run(b))) print('Addtition:%i'%sess.run(a+b)) print('Addtition:%i'%sess.run(a+b)) 然后进行tensor的计算，tensor可以说是tf计算的最基本操作对象了，毕竟名字就叫tensorflow，对tensor的运算有多重要不言而喻。1234567891011import tensorflow as tfrow_dim = 3col_dim=3# generate random numbers from a uniform distributiona=tf.random_uniform([row_dim, col_dim], minval=0, maxval=1)# generate random numbers from a normal distributionb=tf.random_normal([row_dim, col_dim], mean=0.0, stddev=1.0)with tf.Session() as sess: print((sess.run(a), sess.run(b))) print(sess.run(a*b)) print(sess.run(a+b)) 数学运算可能会用到的一些函数：12345678910111213tf.addtf.subtf.multiply #这个和*一样的。如果shape一样对应元素相乘。不一样的时候broadcast。tf.divtf.modtf.abs tf.negtf.signtf.invtf.squaretf.roundtf.sqrt tf.pow tf.exp tf.log tf.maximumtf.minimumtf.cos tf.sin 对二维张量的一些计算：12345tf.diag生成对角阵tf.transpose转置tf.matmul矩阵乘法 #（2,3）×（3,2）-&gt;(2,2)tf.matrix_determinant计算行列式的值tf.matrix_inverse计算矩阵的逆 引用https://zhuanlan.zhihu.com/p/30487008https://www.jianshu.com/p/6fec37e6ccc1]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow学习笔记0（简介）]]></title>
    <url>%2F2018%2F03%2F07%2FTensorflow0%2F</url>
    <content type="text"><![CDATA[Preface之前其实也用了快一年Tensorflow, 但是实际上很多具体的实现并没有很清楚, 所以决定从头学一遍，边学变记吧。会参考一些别的教程，结合自己的理解，把学习的内容整理下来和大家分享。从基本的变量，计算图的搭建开始，后面实现一些常用的网络结构，Alexnet， VGG， Resnet之类。争取一个月之内全部更完。这一系列笔记主要针对的是tf模型和api的复习，所以关于神经网络方面的内容就不深入了写了。 笔记目录 tf基本元素 变量与计算图搭建 mnist和cnn tensorboard可视化 Alexnet tf.slim VGG Resnet]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
        <tag>Deeplearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018机器学习实习面试知识点整理]]></title>
    <url>%2F2018%2F03%2F06%2F2018intern_interview%2F</url>
    <content type="text"><![CDATA[算是第一次正式的跟职场接触, 刚开始的时候也是一头雾水的状态。面得多了也慢慢有经验, 除了第一个头条挂了, 嗯挂的很惨。也是很想去的一家公司, 但是第一次哎, 多半会这样, 有种似曾相识的感觉。后面的除了阿里还没有回复, 一共拿了5个offer, 还算满意了吧。有些遗憾的是因为时间不合适, 没有去尝试一些大厂, 下次一定要补上。 这里总结的问题一部分是我自己遇到的, 还有一大部分是网上看了别人的面经摘抄或者总结出来的。还有一些有意思的问题, 因为懒也没有来得及写上, 以后会慢慢补充。很多地方可能考虑不周, 或者有别的角度, 欢迎大家补充或者指出。面试准备:针对简历问题项目用到的特征 Auto Color Correlogram (acc)颜色自动相关图（color auto-correlogram），它仅仅考察具有相同颜色的像素间的空间关系 Color and Edge Directivity Descriptor (cedd)CEDD结合了图像的颜色和纹理信息，生成一个144位的直方图。1.1.RGB模型转换为HSV模型H （Hue）代表色调，指通过物体传播或从物体射出的颜色，一般在使用中是由颜色名称来标识的。S （Saturation）代表饱和度，表示色调中灰色成分的比例，指颜色的纯度或强度。V （Value）代表亮度. Color Layout (cl)Color Layout Descriptor是mpeg-7多媒体内容标准描述中一种高效的局部颜色特征描述，在基于内容的图像检索(Content Based Image Retrieval (CBIR) ) 中表现出很好性能，拥有计算成本低，匹配计算速度快，识别准确率高等优点。可以用来做以图搜图 Edge Histogram (eh) Fuzzy Color and Texture Histogram (fcth)模糊颜色和纹理直方图 Gabor (gabor)Gabor 特征是一种可以用来描述图像纹理信息的特征，Gabor 滤波器的频率和方向与人类的视觉系统类似，特别适合于纹理表示与判别。从图像处理的角度来看，Gabor特征有如下好处：（1）Gabor核函数由于去掉了直流分量，因此对局部光照的变化不敏感，常常被用在要求对光照有适应性的场合；（2）Gabor滤波结果可以反映图像不同尺度、不同方向上的灰度分布信息。一般说来，大尺度滤波可以反映全局性较强的信息，同时可以掩盖图像中噪声的影响；小尺度可以反映比较精细的局部结构，但容易受到噪声影响。 Joint descriptor joining CEDD and FCTH in one histogram (jcd) Scalable Color (sc)基于MPEG-7推荐的可伸缩颜色描述符 Tamura (tamura)Tamura 纹理特征基于人类对纹理的视觉感知心理学研究，提出6种属性，即：粗糙度、对比度、方向度、线像度、规整度和粗略度。 Local Binary Patterns (lbp) LBP特征(从灰度图提取)下图反应了某个像素的具体的LBP特征值的计算过程，需要注意的是，LBP值是按照顺时针方向组成的二进制数。用公式来定义的话，如下所示：其中代表3x3邻域的中心元素，它的像素值为ic，ip代表邻域内其他像素的值。s(x)是符号函数，定义如下： HOG特征(从灰度图提取)方向梯度直方图（Histogram of Oriented Gradient, HOG）计算图像横坐标和纵坐标方向的梯度，并据此计算每个像素位置的梯度方向值；求导操作不仅能够捕获轮廓，人影和一些纹理信息，还能进一步弱化光照的影响。图像中像素点(x,y)的梯度为： 最常用的方法是：首先用[-1,0,1]梯度算子对原图像做卷积运算，得到x方向（水平方向，以向右为正方向）的梯度分量gradscalx，然后用[1,0,-1]T梯度算子对原图像做卷积运算，得到y方向（竖直方向，以向上为正方向）的梯度分量gradscaly。然后再用以上公式计算该像素点的梯度大小和方向。（3）为每个细胞单元构建梯度方向直方图（4）把细胞单元组合成大的块（block），块内归一化梯度直方图 ORB特征(提取特征点)ORB：An Efficient Alternative to SIFT or SURF 调参目的：偏差和方差的协调！！！bias，variance原则：模型从简单到复杂，避免过拟合传统方法：1）树类分类器n_estimators:子模型数量max_features:每个子树能用到的最大特征。一般去总特征数开方或者log或者全部max_depth:最大深度min_sample_split:min_sample_leaf:神经网络：learning rate: 1 0.1 0.01 0.001, 一般从1开始尝试。很少见learning rate大于10的。学习率一般要随着训练进行衰减。衰减系数一般是0.5。 衰减时机，可以是验证集准确率不再上升时，或固定训练多少个周期以后。不过更建议使用自适应梯度的办法，例如adam,adadelta,rmsprop等，这些一般使用相关论文提供的默认值即可，可以避免再费劲调节学习率。对RNN来说，有个经验，如果RNN要处理的序列比较长，或者RNN层数比较多，那么learning rate一般小一些比较好，否则有可能出现结果不收敛，甚至Nan等问题。网络层数： 先从1层开始。每层结点数： 16 32 128，超过1000的情况比较少见。超过1W的从来没有见过。batch size: 128上下开始。batch size值增加，的确能提高训练速度。但是有可能收敛结果变差。如果显存大小允许，可以考虑从一个比较大的值开始尝试。因为batch size太大，一般不会对结果有太大的影响，而batch size太小的话，结果有可能很差。clip c(梯度裁剪): 限制最大梯度,其实是value = sqrt(w1^2+w2^2….),如果value超过了阈值，就算一个衰减系系数,让value的值等于阈值: 5,10,15dropout： 0.5L2正则：1.0，超过10的很少见。正负样本比例： 这个是非常忽视，但是在很多分类问题上，又非常重要的参数。很多人往往习惯使用训练数据中默认的正负类别比例，当训练数据非常不平衡的时候，模型很有可能会偏向数目较大的类别，从而影响最终训练结果。除了尝试训练数据默认的正负类别比例之外，建议对数目较小的样本做过采样，例如进行复制。提高他们的比例，看看效果如何，这个对多分类问题同样适用。在使用mini-batch方法进行训练的时候，尽量让一个batch内，各类别的比例平衡，这个在图像识别等多分类任务上非常重要。 什么是boosting tree（加法模型+前向分布）Boosting方法： Boosting这其实思想相当的简单，大概是，对一份数据，建立M个模型（比如分类），一般这种模型比较简单，称为弱分类器(weak learner)每次分类都将上一次分错的数据权重提高一点再进行分类，这样最终得到的分类器在测试数据与训练数据上都可以得到比较好的成绩。前向分布算法 实际上是一个贪心的算法，也就是在每一步求解弱分类器Φ(m)和其参数w(m)的时候不去修改之前已经求好的分类器和参数。用当前模型的残差，即r=y-fm(x), 来计算下一颗树的参数。 GBDT梯度提升与普通boosting的区别是，利用的是损失函数的负梯度在当前函数的值来拟合回归树。算法： XGB传统GBDT在优化时只用到一阶导数信息，xgboost则对代价函数进行了二阶泰勒展开，同时用到了一阶和二阶导数。顺便提一下，xgboost工具支持自定义代价函数，只要函数可一阶和二阶求导。xgboost在代价函数里加入了正则项，用于控制模型的复杂度。正则项里包含了树的叶子节点个数、每个叶子节点上输出的score的L2模的平方和。从Bias-variance tradeoff角度来讲，正则项降低了模型的variance，使学习出来的模型更加简单，防止过拟合，这也是xgboost优于传统GBDT的一个特性。xgboost工具支持并行。xgboost的并行是在特征粒度上的。我们知道，决策树的学习最耗时的一个步骤就是对特征的值进行排序（因为要确定最佳分割点），xgboost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行。 L1和L2正则为什么可以减弱overfitting欠拟合(underfitting)，或者叫作叫做高偏差(bias).过拟合(overfitting)，也叫高方差(variance).越简单的模型泛化能力越强。对高阶项进行一定的惩罚，避免模型在数据量不够的时候过于复杂。Ps：防止过拟合的其他方法，early stopping、数据集扩增（Data augmentation），dropoutL1和L2正则有什么区别L1范数和L0范数可以实现稀疏（使没用的特征为0），L1因具有比L0更好的优化求解特性而被广泛应用。L1使损失函数可导。L2范数不但可以防止过拟合，还可以让我们的优化求解变得稳定和快速。L1会趋向于产生少量的特征，而其他的特征都是0，而L2会选择更多的特征，这些特征都会接近于0。Lasso在特征选择时候非常有用，而Ridge就只是一种规则化而已。为什么L1正则可以实现参数稀疏，而L2正则不可以？答了：L1正则因为是绝对值形式，很多系数被压缩为0,。而L2正则是很多系数被压迫到接近于0，而不是0为什么L1很多系数可以被压缩为0，L2是被压缩至接近于0？答了：图像上，L1正则是正方形，L2正则是圆形。L1正则的往往取到正方形顶点，即有很多参数为0.L2正则往往去不到圆形和参数线的交点，即很多分量被压缩到接近于0 怎么理解dropout在每次训练的时候使用dropout，每个神经元有一定的概率被移除，这样可以使得一个神经元的训练不依赖于另外一个神经元，同样也就使得特征之间的协同作用被减弱。Hinton认为，过拟合可以通过阻止某些特征的协同作用来缓解。增加鲁棒性。也可以理解为相当于在训练不同的网络，最后投票来决定结果。 KNN和Lr有什么本质区别LR属于线性模型。因为 logistic 回归的决策边界（decision boundary）是线性的。KNN属于非线性模型 学习率如何影响训练？如果学习率很低，训练会变得更加可靠，但是优化会耗费较长的时间，因为朝向损失函数最小值的每个步长很小。如果学习率很高，训练可能根本不会收敛，甚至会发散。权重的改变量可能非常大，使得优化越过最小值，使得损失函数变得更糟。 如何解决样本不均衡的问题?从数据集外补充, 我的项目里直接从网上爬图片, 加上SMOTE等过采样的算法(有好多种, 各有优劣, SMOTE应该是最好的), 以及对图片进行一些几何上的处理。 线性分类器和非线性分类器线性分类器：模型是参数的线性函数，分类平面是（超）平面；非线性分类器：模型分界面可以是曲面或者超平面的组合。典型的线性分类器有感知机，LDA，逻辑斯特回归，SVM（线性核；典型的非线性分类器有朴素贝叶斯（有文章说这个本质是线性的，http://dataunion.org/12344.html），kNN，决策树，SVM（非线性核） 为什么random forest具有特征选择的功能树类分类器其实都可以, 因为可以判断每个特征对应的信息增益, 信息增益越大的特征分类效果理论上来说就越好。在非结构话数据的项目中常常会用这种方法来选取有用的特征, 从而降低特征维度。在特特征维度高的时候还是特别好用的。 random forest有哪些重要的参数？A. max_features：随机森林允许单个决策树使用特征的最大数量。 Python为最大特征数提供了多个可选项。 下面是其中的几个：Auto/None ：简单地选取所有特征，每颗树都可以利用他们。这种情况下，每颗树都没有任何的限制。sqrt ：此选项是每颗子树可以利用总特征数的平方根个。 例如，如果变量（特征）的总数是100，所以每颗子树只能取其中的10个。“log2”是另一种相似类型的选项。0.2：此选项允许每个随机森林的子树可以利用变量（特征）数的20％。如果想考察的特征x％的作用， 我们可以使用“0.X”的格式。max_features如何影响性能和速度？增加max_features一般能提高模型的性能，因为在每个节点上，我们有更多的选择可以考虑。 然而，这未必完全是对的，因为它降低了单个树的多样性，而这正是随机森林独特的优点。 但是，可以肯定，你通过增加max_features会降低算法的速度。 因此，你需要适当的平衡和选择最佳max_features。B. n_estimators：在利用最大投票数或平均值来预测之前，你想要建立子树的数量。 较多的子树可以让模型有更好的性能，但同时让你的代码变慢。 你应该选择尽可能高的值，只要你的处理器能够承受的住，因为这使你的预测更好更稳定。C. min_sample_leaf：如果您以前编写过一个决策树，你能体会到最小样本叶片大小的重要性。 叶是决策树的末端节点。 较小的叶子使模型更容易捕捉训练数据中的噪声。 一般来说，我更偏向于将最小叶子节点数目设置为大于50。在你自己的情况中，你应该尽量尝试多种叶子大小种类，以找到最优的那个。 为什么梯度反方向是函数值局部下降最快的方向？那么此时如果要取得最大值，也就是当为0度的时候，也就是向量(这个方向是一直在变，在寻找一个函数变化最快的方向）与向量（这个方向当点固定下来的时候，它就是固定的）平行的时候，方向导数最大.方向导数最大，也就是单位步伐，函数值朝这个反向变化最快. DNN为什么功能强大，说说你的理解深度学习的深度一方面增加了大量的参数，增加的参数意味着这个网络的表达能力更强大了。可以学习和区分的特征更多了。而一旦学习到的特征变多的话，我们在分类和识别的能力也就变好了。从简单特征到抽象特征。随着网络深度增加，提取的特征不断复杂化。更能理解复杂概念。 SVM的损失函数是什么？怎么理解2分类SVM等于Hinge损失 + L2正则化。SVM最大化分类间距的目标函数等价于最小化Hinge损失 + L2正则化。推导并不复杂, 详见《统计学习方法》。 介绍下Maxoutmaxout激活函数，它具有如下性质：1、maxout激活函数并不是一个固定的函数，不像Sigmod、Relu、Tanh等函数，是一个固定的函数方程2、它是一个可学习的激活函数，因为我们W参数是学习变化的。3、它是一个分段线性函数：maxout的拟合能力是非常强的，它可以拟合任意的的凸函数。最直观的解释就是任意的凸函数都可以由分段线性函数以任意精度拟合（学过高等数学应该能明白），而maxout又是取k个隐隐含层节点的最大值，这些”隐隐含层”节点也是线性的，所以在不同的取值范围下，最大值也可以看做是分段线性的（分段的个数与k值有关） 根据混淆矩阵可以得到评价分类模型的指标有以下几种。分类准确度，就是正负样本分别被正确分类的概率，计算公式为：召回率，就是正样本被识别出的概率，计算公式为：虚警率，就是负样本被错误分为正样本的概率，计算公式为：精确度，就是分类结果为正样本的情况真实性程度，计算公式为： 优化器类型 Batch gradient descent梯度更新规则:BGD 采用整个训练集的数据来计算 cost function 对参数的梯度：Batch gradient descent 对于凸函数可以收敛到全局极小值，对于非凸函数可以收敛到局部极小值。 Stochastic gradient descent梯度更新规则:和 BGD 的一次用所有数据计算梯度相比，SGD 每次更新时对每个样本进行梯度更新，对于很大的数据集来说，可能会有相似的样本，这样 BGD 在计算梯度时会出现冗余，而 SGD 一次只进行一次更新，就没有冗余，而且比较快，并且可以新增样本。缺点:但是 SGD 因为更新比较频繁，会造成 cost function 有严重的震荡。BGD 可以收敛到局部极小值，当然 SGD 的震荡可能会跳到更好的局部极小值处。 3.Adam自适应优化器，能够自发地改变学习率。效果最好。存储了过去梯度的平方 vt 的指数衰减平均值 ，也像 momentum 一样保持了过去梯度 mt 的指数衰减平均值：梯度更新规则:超参数设定值:建议 β1 ＝ 0.9，β2 ＝ 0.999，ϵ ＝ 10e−8实践表明，Adam 比其他适应性学习方法效果要好 什么是梯度消失？怎么解决梯度消失问题发生时，接近于输出层的hidden layer 3等的权值更新相对正常，但前面的hidden layer 1的权值更新会变得很慢，导致前面的层权值几乎不变，仍接近于初始化的权值，这就导致hidden layer 1相当于只是一个映射层，对所有的输入做了一个同一映射，这是此深层网络的学习就等价于只有后几层的浅层网络的学习了。其实梯度爆炸和梯度消失问题都是因为网络太深，链式求导，网络权值更新不稳定造成的，本质上是因为梯度反向传播中的连乘效应。对于更普遍的梯度消失问题，可以考虑用ReLU激活函数取代sigmoid激活函数。 batch normalisation作用那BN到底是什么原理呢？说到底还是为了防止“梯度弥散”。关于梯度弥散，大家都知道一个简单的栗子：在BN中，是通过将activation规范为均值和方差一致的手段使得原本会减小的activation的scale变大。可以说是一种更有效的local response normalization方法。 LSTM模型介绍和BPTT推导 LR 和 linear SVM区别相同点：1，LR和SVM都是分类算法。2，如果不考虑核函数，LR和SVM都是线性分类算法，即分类决策面都是线性的。3，LR和SVM都是监督学习算法。不同点：1，本质上是其loss function不同。2，支持向量机只考虑局部的边界线附近的点，而逻辑回归考虑全局（远离的点对边界线的确定也起作用）。线性SVM不直接依赖于数据分布，分类平面不受一类点影响；LR则受所有数据点的影响，如果数据不同类别strongly unbalance，一般需要先对数据做balancing。3，在解决非线性问题时，支持向量机采用核函数的机制，而LR通常不采用核函数的方法。这个问题理解起来非常简单。分类模型的结果就是计算决策面，模型训练的过程就是决策面的计算过程。通过上面的第二点不同点可以了解，在计算决策面时，SVM算法里只有少数几个代表支持向量的样本参与了计算，也就是只有少数几个样本需要参与核计算（即kernal machine解的系数是稀疏的）。然而，LR算法里，每个样本点都必须参与决策面的计算过程，也就是说，假设我们在LR里也运用核函数的原理，那么每个样本点都必须参与核计算，这带来的计算复杂度是相当高的。所以，在具体应用时，LR很少运用核函数机制。4，线性SVM依赖数据表达的距离测度，所以需要对数据先做normalization，LR不受其影响。5，SVM的损失函数就自带正则！！！（损失函数中的1/2||w||^2项），这就是为什么SVM是结构风险最小化算法的原因！！！而LR必须另外在损失函数上添加正则项！！！在Andrew NG的课里讲到过： 如果Feature的数量很大，跟样本数量差不多，这时候选用LR或者是Linear Kernel的SVM 如果Feature的数量比较小，样本数量一般，不算大也不算小，选用SVM+Gaussian Kernel 如果Feature的数量比较小，而样本数量很多，需要手工添加一些feature变成第一种情况 SVM面试问题为什么要把原问题转换为对偶问题？因为原问题是凸二次规划问题，转换为对偶问题更加高效。为什么求解对偶问题更加高效？因为只用求解alpha系数，而alpha系数只有支持向量才非0，其他全部为0.alpha系数有多少个？样本点的个数 线性回归基本假设?线性回归需要满足四个前提假设.LINE!!! Linearity 线性. 应变量和每个自变量都是线性关系。 Indpendence 独立性. 对于所有的观测值，它们的误差项相互之间是独立的。 Normality 正态性. 误差项服从正态分布。 Equal-variance 等方差. 所有的误差项具有同样方差。 用cos做激活函数行不行?答案是可以的, 面试的时候想太多答得不好。当时觉得cos容易使得模型出现梯度消失的情况, 但是其实要看具体的问题, cos在某些问题上表现得很好。其实激活函数的目的是为了使模型具有非线性, 否则再深的神经网络到最后也只是一个线性分类器。一个好的激活函数应该有如下几个标准(摘自知乎):作者：Hengkai Guo链接：https://www.zhihu.com/question/67366051/answer/262087707来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 非线性：即导数不是常数。这个条件前面很多答主都提到了，是多层神经网络的基础，保证多层网络不退化成单层线性网络。这也是激活函数的意义所在。 几乎处处可微：可微性保证了在优化中梯度的可计算性。传统的激活函数如sigmoid等满足处处可微。对于分段线性函数比如ReLU，只满足几乎处处可微（即仅在有限个点处不可微）。对于SGD算法来说，由于几乎不可能收敛到梯度接近零的位置，有限的不可微点对于优化结果不会有很大影响[1]。 计算简单：正如题主所说，非线性函数有很多。极端的说，一个多层神经网络也可以作为一个非线性函数，类似于Network In Network[2]中把它当做卷积操作的做法。但激活函数在神经网络前向的计算次数与神经元的个数成正比，因此简单的非线性函数自然更适合用作激活函数。这也是ReLU之流比其它使用Exp等操作的激活函数更受欢迎的其中一个原因。 非饱和性（saturation）：饱和指的是在某些区间梯度接近于零（即梯度消失），使得参数无法继续更新的问题。最经典的例子是Sigmoid，它的导数在x为比较大的正值和比较小的负值时都会接近于0。更极端的例子是阶跃函数，由于它在几乎所有位置的梯度都为0，因此处处饱和，无法作为激活函数。ReLU在x&gt;0时导数恒为1，因此对于再大的正值也不会饱和。但同时对于x&lt;0，其梯度恒为0，这时候它也会出现饱和的现象（在这种情况下通常称为dying ReLU）。Leaky ReLU[3]和PReLU[4]的提出正是为了解决这一问题。 单调性（monotonic）：即导数符号不变。这个性质大部分激活函数都有，除了诸如sin、cos等。个人理解，单调性使得在激活函数处的梯度方向不会经常改变，从而让训练更容易收敛。 输出范围有限：有限的输出范围使得网络对于一些比较大的输入也会比较稳定，这也是为什么早期的激活函数都以此类函数为主，如Sigmoid、TanH。但这导致了前面提到的梯度消失问题，而且强行让每一层的输出限制到固定范围会限制其表达能力。因此现在这类函数仅用于某些需要特定输出范围的场合，比如概率输出（此时loss函数中的log操作能够抵消其梯度消失的影响[1]）、LSTM里的gate函数。7. 接近恒等变换（identity）：即约等于x。这样的好处是使得输出的幅值不会随着深度的增加而发生显著的增加，从而使网络更为稳定，同时梯度也能够更容易地回传。这个与非线性是有点矛盾的，因此激活函数基本只是部分满足这个条件，比如TanH只在原点附近有线性区（在原点为0且在原点的导数为1），而ReLU只在x&gt;0时为线性。这个性质也让初始化参数范围的推导更为简单[5][4]。额外提一句，这种恒等变换的性质也被其他一些网络结构设计所借鉴，比如CNN中的ResNet[6]和RNN中的LSTM。 参数少：大部分激活函数都是没有参数的。像PReLU带单个参数会略微增加网络的大小。还有一个例外是Maxout[7]，尽管本身没有参数，但在同样输出通道数下k路Maxout需要的输入通道数是其它函数的k倍，这意味着神经元数目也需要变为k倍；但如果不考虑维持输出通道数的情况下，该激活函数又能将参数个数减少为原来的k倍。 归一化（normalization）：这个是最近才出来的概念，对应的激活函数是SELU[8]，主要思想是使样本分布自动归一化到零均值、单位方差的分布，从而稳定训练。在这之前，这种归一化的思想也被用于网络结构的设计，比如Batch Normalization[9]。 To be solved…项目中over-fitting了，你怎么办详细说一个你知道的优化算法(Adam等)项目(比赛）怎么做的模型的ensemblestacking是什么？需要注意哪些问题了解哪些online learning的算法如何解决样本不均衡的问题fasterRCNN中的ROIPooling是如何实现的如何进行特征的选择如何进行模型的选择常用的有哪些损失函数XX用户画像挖掘怎么做的feature engineering?假设一个5*5的filter与图像卷积，如何降低计算量？做过模型压缩吗？介绍下什么是residual learning？说说你的理解residual learning所说的residual和GBDT中的residual有什么区别？FFM和FTRL有过了解吗？你对现在Deep Learning的发展和遇到的问题有什么看法？]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在开始]]></title>
    <url>%2F2018%2F03%2F05%2F%E5%86%99%E5%9C%A8%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[其实写一个个人网站是一个已经酝酿许久的想法, 但是一直太懒, 也没有时间;), 所以就耽搁下了。这次趁着在法国生活即将结束之际, 偷懒地用github把这个小计划也实现了。以后会在这里写些技术文章, 机器学习, 算法, AI估计都会有, 希望能和大家共同进步吧, 和一些无病呻吟的文章, 毕竟生活还需要记录和一些仪式感。马上就要回国了, 总算可以专心写代码学算法了, 之前学的时候都太仓促, 以后要多总结下。最后, 要把写博客的习惯坚持下去。以上]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>无病呻吟</tag>
      </tags>
  </entry>
</search>
